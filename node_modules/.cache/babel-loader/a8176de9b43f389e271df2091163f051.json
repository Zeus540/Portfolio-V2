{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RecognizerEngine = void 0;\n\nvar utils_1 = require(\"@chevrotain/utils\");\n\nvar keys_1 = require(\"../../grammar/keys\");\n\nvar exceptions_public_1 = require(\"../../exceptions_public\");\n\nvar lookahead_1 = require(\"../../grammar/lookahead\");\n\nvar interpreter_1 = require(\"../../grammar/interpreter\");\n\nvar parser_1 = require(\"../parser\");\n\nvar recoverable_1 = require(\"./recoverable\");\n\nvar tokens_public_1 = require(\"../../../scan/tokens_public\");\n\nvar tokens_1 = require(\"../../../scan/tokens\");\n\nvar lang_extensions_1 = require(\"../../../lang/lang_extensions\");\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\n\n\nvar RecognizerEngine =\n/** @class */\nfunction () {\n  function RecognizerEngine() {}\n\n  RecognizerEngine.prototype.initRecognizerEngine = function (tokenVocabulary, config) {\n    this.className = (0, lang_extensions_1.classNameFromInstance)(this); // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n\n    this.shortRuleNameToFull = {};\n    this.fullRuleNameToShort = {};\n    this.ruleShortNameIdx = 256;\n    this.tokenMatcher = tokens_1.tokenStructuredMatcherNoCategories;\n    this.definedRulesNames = [];\n    this.tokensMap = {};\n    this.isBackTrackingStack = [];\n    this.RULE_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n    this.gastProductionsCache = {};\n\n    if ((0, utils_1.has)(config, \"serializedGrammar\")) {\n      throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" + \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" + \"\\tFor Further details.\");\n    }\n\n    if ((0, utils_1.isArray)(tokenVocabulary)) {\n      // This only checks for Token vocabularies provided as arrays.\n      // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n      // rather than all edge cases of empty Token vocabularies.\n      if ((0, utils_1.isEmpty)(tokenVocabulary)) {\n        throw Error(\"A Token Vocabulary cannot be empty.\\n\" + \"\\tNote that the first argument for the parser constructor\\n\" + \"\\tis no longer a Token vector (since v4.0).\");\n      }\n\n      if (typeof tokenVocabulary[0].startOffset === \"number\") {\n        throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\" + \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" + \"\\tFor Further details.\");\n      }\n    }\n\n    if ((0, utils_1.isArray)(tokenVocabulary)) {\n      this.tokensMap = (0, utils_1.reduce)(tokenVocabulary, function (acc, tokType) {\n        acc[tokType.name] = tokType;\n        return acc;\n      }, {});\n    } else if ((0, utils_1.has)(tokenVocabulary, \"modes\") && (0, utils_1.every)((0, utils_1.flatten)((0, utils_1.values)(tokenVocabulary.modes)), tokens_1.isTokenType)) {\n      var allTokenTypes = (0, utils_1.flatten)((0, utils_1.values)(tokenVocabulary.modes));\n      var uniqueTokens = (0, utils_1.uniq)(allTokenTypes);\n      this.tokensMap = (0, utils_1.reduce)(uniqueTokens, function (acc, tokType) {\n        acc[tokType.name] = tokType;\n        return acc;\n      }, {});\n    } else if ((0, utils_1.isObject)(tokenVocabulary)) {\n      this.tokensMap = (0, utils_1.cloneObj)(tokenVocabulary);\n    } else {\n      throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors,\" + \" A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n    } // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n    // parsed with a clear error message (\"expecting EOF but found ...\")\n\n    /* tslint:disable */\n\n\n    this.tokensMap[\"EOF\"] = tokens_public_1.EOF; // TODO: This check may not be accurate for multi mode lexers\n\n    var noTokenCategoriesUsed = (0, utils_1.every)((0, utils_1.values)(tokenVocabulary), function (tokenConstructor) {\n      return (0, utils_1.isEmpty)(tokenConstructor.categoryMatches);\n    });\n    this.tokenMatcher = noTokenCategoriesUsed ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher; // Because ES2015+ syntax should be supported for creating Token classes\n    // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n    // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n\n    (0, tokens_1.augmentTokenTypes)((0, utils_1.values)(this.tokensMap));\n  };\n\n  RecognizerEngine.prototype.defineRule = function (ruleName, impl, config) {\n    if (this.selfAnalysisDone) {\n      throw Error(\"Grammar rule <\" + ruleName + \"> may not be defined after the 'performSelfAnalysis' method has been called'\\n\" + \"Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.\");\n    }\n\n    var resyncEnabled = (0, utils_1.has)(config, \"resyncEnabled\") ? config.resyncEnabled : parser_1.DEFAULT_RULE_CONFIG.resyncEnabled;\n    var recoveryValueFunc = (0, utils_1.has)(config, \"recoveryValueFunc\") ? config.recoveryValueFunc : parser_1.DEFAULT_RULE_CONFIG.recoveryValueFunc; // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n    // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n\n    /* tslint:disable */\n\n    var shortName = this.ruleShortNameIdx << keys_1.BITS_FOR_METHOD_TYPE + keys_1.BITS_FOR_OCCURRENCE_IDX;\n    /* tslint:enable */\n\n    this.ruleShortNameIdx++;\n    this.shortRuleNameToFull[shortName] = ruleName;\n    this.fullRuleNameToShort[ruleName] = shortName;\n\n    function invokeRuleWithTry(args) {\n      try {\n        if (this.outputCst === true) {\n          impl.apply(this, args);\n          var cst = this.CST_STACK[this.CST_STACK.length - 1];\n          this.cstPostRule(cst);\n          return cst;\n        } else {\n          return impl.apply(this, args);\n        }\n      } catch (e) {\n        return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n      } finally {\n        this.ruleFinallyStateUpdate();\n      }\n    }\n\n    var wrappedGrammarRule = function (idxInCallingRule, args) {\n      if (idxInCallingRule === void 0) {\n        idxInCallingRule = 0;\n      }\n\n      this.ruleInvocationStateUpdate(shortName, ruleName, idxInCallingRule);\n      return invokeRuleWithTry.call(this, args);\n    };\n\n    var ruleNamePropName = \"ruleName\";\n    wrappedGrammarRule[ruleNamePropName] = ruleName;\n    wrappedGrammarRule[\"originalGrammarAction\"] = impl;\n    return wrappedGrammarRule;\n  };\n\n  RecognizerEngine.prototype.invokeRuleCatch = function (e, resyncEnabledConfig, recoveryValueFunc) {\n    var isFirstInvokedRule = this.RULE_STACK.length === 1; // note the reSync is always enabled for the first rule invocation, because we must always be able to\n    // reSync with EOF and just output some INVALID ParseTree\n    // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n    // path is really the most valid one\n\n    var reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n\n    if ((0, exceptions_public_1.isRecognitionException)(e)) {\n      var recogError = e;\n\n      if (reSyncEnabled) {\n        var reSyncTokType = this.findReSyncTokenType();\n\n        if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n          recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n\n          if (this.outputCst) {\n            var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            return partialCstResult;\n          } else {\n            return recoveryValueFunc();\n          }\n        } else {\n          if (this.outputCst) {\n            var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            recogError.partialCstResult = partialCstResult;\n          } // to be handled Further up the call stack\n\n\n          throw recogError;\n        }\n      } else if (isFirstInvokedRule) {\n        // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n        this.moveToTerminatedState(); // the parser should never throw one of its own errors outside its flow.\n        // even if error recovery is disabled\n\n        return recoveryValueFunc();\n      } else {\n        // to be recovered Further up the call stack\n        throw recogError;\n      }\n    } else {\n      // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n      throw e;\n    }\n  }; // Implementation of parsing DSL\n\n\n  RecognizerEngine.prototype.optionInternal = function (actionORMethodDef, occurrence) {\n    var key = this.getKeyForAutomaticLookahead(keys_1.OPTION_IDX, occurrence);\n    return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n  };\n\n  RecognizerEngine.prototype.optionInternalLogic = function (actionORMethodDef, occurrence, key) {\n    var _this = this;\n\n    var lookAheadFunc = this.getLaFuncFromCache(key);\n    var action;\n    var predicate;\n\n    if (actionORMethodDef.DEF !== undefined) {\n      action = actionORMethodDef.DEF;\n      predicate = actionORMethodDef.GATE; // predicate present\n\n      if (predicate !== undefined) {\n        var orgLookaheadFunction_1 = lookAheadFunc;\n\n        lookAheadFunc = function () {\n          return predicate.call(_this) && orgLookaheadFunction_1.call(_this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n\n    if (lookAheadFunc.call(this) === true) {\n      return action.call(this);\n    }\n\n    return undefined;\n  };\n\n  RecognizerEngine.prototype.atLeastOneInternal = function (prodOccurrence, actionORMethodDef) {\n    var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_IDX, prodOccurrence);\n    return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n  };\n\n  RecognizerEngine.prototype.atLeastOneInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n    var _this = this;\n\n    var lookAheadFunc = this.getLaFuncFromCache(key);\n    var action;\n    var predicate;\n\n    if (actionORMethodDef.DEF !== undefined) {\n      action = actionORMethodDef.DEF;\n      predicate = actionORMethodDef.GATE; // predicate present\n\n      if (predicate !== undefined) {\n        var orgLookaheadFunction_2 = lookAheadFunc;\n\n        lookAheadFunc = function () {\n          return predicate.call(_this) && orgLookaheadFunction_2.call(_this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n\n    if (lookAheadFunc.call(this) === true) {\n      var notStuck = this.doSingleRepetition(action);\n\n      while (lookAheadFunc.call(this) === true && notStuck === true) {\n        notStuck = this.doSingleRepetition(action);\n      }\n    } else {\n      throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n    } // note that while it may seem that this can cause an error because by using a recursive call to\n    // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n    // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n\n\n    this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, keys_1.AT_LEAST_ONE_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneWalker);\n  };\n\n  RecognizerEngine.prototype.atLeastOneSepFirstInternal = function (prodOccurrence, options) {\n    var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n    this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n  };\n\n  RecognizerEngine.prototype.atLeastOneSepFirstInternalLogic = function (prodOccurrence, options, key) {\n    var _this = this;\n\n    var action = options.DEF;\n    var separator = options.SEP;\n    var firstIterationLookaheadFunc = this.getLaFuncFromCache(key); // 1st iteration\n\n    if (firstIterationLookaheadFunc.call(this) === true) {\n      ;\n      action.call(this); //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n      //  because it is only needed in error recovery scenarios.\n\n      var separatorLookAheadFunc = function () {\n        return _this.tokenMatcher(_this.LA(1), separator);\n      }; // 2nd..nth iterations\n\n\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator);\n        action.call(this);\n      } // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n\n\n      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, interpreter_1.NextTerminalAfterAtLeastOneSepWalker], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneSepWalker);\n    } else {\n      throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n    }\n  };\n\n  RecognizerEngine.prototype.manyInternal = function (prodOccurrence, actionORMethodDef) {\n    var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_IDX, prodOccurrence);\n    return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n  };\n\n  RecognizerEngine.prototype.manyInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n    var _this = this;\n\n    var lookaheadFunction = this.getLaFuncFromCache(key);\n    var action;\n    var predicate;\n\n    if (actionORMethodDef.DEF !== undefined) {\n      action = actionORMethodDef.DEF;\n      predicate = actionORMethodDef.GATE; // predicate present\n\n      if (predicate !== undefined) {\n        var orgLookaheadFunction_3 = lookaheadFunction;\n\n        lookaheadFunction = function () {\n          return predicate.call(_this) && orgLookaheadFunction_3.call(_this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n\n    var notStuck = true;\n\n    while (lookaheadFunction.call(this) === true && notStuck === true) {\n      notStuck = this.doSingleRepetition(action);\n    } // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n\n\n    this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, keys_1.MANY_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManyWalker, // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n    // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n    // An infinite loop cannot occur as:\n    // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n    // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n    notStuck);\n  };\n\n  RecognizerEngine.prototype.manySepFirstInternal = function (prodOccurrence, options) {\n    var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_SEP_IDX, prodOccurrence);\n    this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n  };\n\n  RecognizerEngine.prototype.manySepFirstInternalLogic = function (prodOccurrence, options, key) {\n    var _this = this;\n\n    var action = options.DEF;\n    var separator = options.SEP;\n    var firstIterationLaFunc = this.getLaFuncFromCache(key); // 1st iteration\n\n    if (firstIterationLaFunc.call(this) === true) {\n      action.call(this);\n\n      var separatorLookAheadFunc = function () {\n        return _this.tokenMatcher(_this.LA(1), separator);\n      }; // 2nd..nth iterations\n\n\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator); // No need for checking infinite loop here due to consuming the separator.\n\n        action.call(this);\n      } // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n\n\n      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, interpreter_1.NextTerminalAfterManySepWalker], separatorLookAheadFunc, keys_1.MANY_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManySepWalker);\n    }\n  };\n\n  RecognizerEngine.prototype.repetitionSepSecondInternal = function (prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n    while (separatorLookAheadFunc()) {\n      // note that this CONSUME will never enter recovery because\n      // the separatorLookAheadFunc checks that the separator really does exist.\n      this.CONSUME(separator);\n      action.call(this);\n    } // we can only arrive to this function after an error\n    // has occurred (hence the name 'second') so the following\n    // IF will always be entered, its possible to remove it...\n    // however it is kept to avoid confusion and be consistent.\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n\n    /* istanbul ignore else */\n\n\n    this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n  };\n\n  RecognizerEngine.prototype.doSingleRepetition = function (action) {\n    var beforeIteration = this.getLexerPosition();\n    action.call(this);\n    var afterIteration = this.getLexerPosition(); // This boolean will indicate if this repetition progressed\n    // or if we are \"stuck\" (potential infinite loop in the repetition).\n\n    return afterIteration > beforeIteration;\n  };\n\n  RecognizerEngine.prototype.orInternal = function (altsOrOpts, occurrence) {\n    var laKey = this.getKeyForAutomaticLookahead(keys_1.OR_IDX, occurrence);\n    var alts = (0, utils_1.isArray)(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n    var laFunc = this.getLaFuncFromCache(laKey);\n    var altIdxToTake = laFunc.call(this, alts);\n\n    if (altIdxToTake !== undefined) {\n      var chosenAlternative = alts[altIdxToTake];\n      return chosenAlternative.ALT.call(this);\n    }\n\n    this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n  };\n\n  RecognizerEngine.prototype.ruleFinallyStateUpdate = function () {\n    this.RULE_STACK.pop();\n    this.RULE_OCCURRENCE_STACK.pop(); // NOOP when cst is disabled\n\n    this.cstFinallyStateUpdate();\n\n    if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n      var firstRedundantTok = this.LA(1);\n      var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n        firstRedundant: firstRedundantTok,\n        ruleName: this.getCurrRuleFullName()\n      });\n      this.SAVE_ERROR(new exceptions_public_1.NotAllInputParsedException(errMsg, firstRedundantTok));\n    }\n  };\n\n  RecognizerEngine.prototype.subruleInternal = function (ruleToCall, idx, options) {\n    var ruleResult;\n\n    try {\n      var args = options !== undefined ? options.ARGS : undefined;\n      ruleResult = ruleToCall.call(this, idx, args);\n      this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleToCall.ruleName);\n      return ruleResult;\n    } catch (e) {\n      this.subruleInternalError(e, options, ruleToCall.ruleName);\n    }\n  };\n\n  RecognizerEngine.prototype.subruleInternalError = function (e, options, ruleName) {\n    if ((0, exceptions_public_1.isRecognitionException)(e) && e.partialCstResult !== undefined) {\n      this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleName);\n      delete e.partialCstResult;\n    }\n\n    throw e;\n  };\n\n  RecognizerEngine.prototype.consumeInternal = function (tokType, idx, options) {\n    var consumedToken;\n\n    try {\n      var nextToken = this.LA(1);\n\n      if (this.tokenMatcher(nextToken, tokType) === true) {\n        this.consumeToken();\n        consumedToken = nextToken;\n      } else {\n        this.consumeInternalError(tokType, nextToken, options);\n      }\n    } catch (eFromConsumption) {\n      consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n    }\n\n    this.cstPostTerminal(options !== undefined && options.LABEL !== undefined ? options.LABEL : tokType.name, consumedToken);\n    return consumedToken;\n  };\n\n  RecognizerEngine.prototype.consumeInternalError = function (tokType, nextToken, options) {\n    var msg;\n    var previousToken = this.LA(0);\n\n    if (options !== undefined && options.ERR_MSG) {\n      msg = options.ERR_MSG;\n    } else {\n      msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: tokType,\n        actual: nextToken,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName()\n      });\n    }\n\n    throw this.SAVE_ERROR(new exceptions_public_1.MismatchedTokenException(msg, nextToken, previousToken));\n  };\n\n  RecognizerEngine.prototype.consumeInternalRecovery = function (tokType, idx, eFromConsumption) {\n    // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n    // but the original syntax could have been parsed successfully without any backtracking + recovery\n    if (this.recoveryEnabled && // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n    eFromConsumption.name === \"MismatchedTokenException\" && !this.isBackTracking()) {\n      var follows = this.getFollowsForInRuleRecovery(tokType, idx);\n\n      try {\n        return this.tryInRuleRecovery(tokType, follows);\n      } catch (eFromInRuleRecovery) {\n        if (eFromInRuleRecovery.name === recoverable_1.IN_RULE_RECOVERY_EXCEPTION) {\n          // failed in RuleRecovery.\n          // throw the original error in order to trigger reSync error recovery\n          throw eFromConsumption;\n        } else {\n          throw eFromInRuleRecovery;\n        }\n      }\n    } else {\n      throw eFromConsumption;\n    }\n  };\n\n  RecognizerEngine.prototype.saveRecogState = function () {\n    // errors is a getter which will clone the errors array\n    var savedErrors = this.errors;\n    var savedRuleStack = (0, utils_1.cloneArr)(this.RULE_STACK);\n    return {\n      errors: savedErrors,\n      lexerState: this.exportLexerState(),\n      RULE_STACK: savedRuleStack,\n      CST_STACK: this.CST_STACK\n    };\n  };\n\n  RecognizerEngine.prototype.reloadRecogState = function (newState) {\n    this.errors = newState.errors;\n    this.importLexerState(newState.lexerState);\n    this.RULE_STACK = newState.RULE_STACK;\n  };\n\n  RecognizerEngine.prototype.ruleInvocationStateUpdate = function (shortName, fullName, idxInCallingRule) {\n    this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n    this.RULE_STACK.push(shortName); // NOOP when cst is disabled\n\n    this.cstInvocationStateUpdate(fullName, shortName);\n  };\n\n  RecognizerEngine.prototype.isBackTracking = function () {\n    return this.isBackTrackingStack.length !== 0;\n  };\n\n  RecognizerEngine.prototype.getCurrRuleFullName = function () {\n    var shortName = this.getLastExplicitRuleShortName();\n    return this.shortRuleNameToFull[shortName];\n  };\n\n  RecognizerEngine.prototype.shortRuleNameToFullName = function (shortName) {\n    return this.shortRuleNameToFull[shortName];\n  };\n\n  RecognizerEngine.prototype.isAtEndOfInput = function () {\n    return this.tokenMatcher(this.LA(1), tokens_public_1.EOF);\n  };\n\n  RecognizerEngine.prototype.reset = function () {\n    this.resetLexerState();\n    this.isBackTrackingStack = [];\n    this.errors = [];\n    this.RULE_STACK = []; // TODO: extract a specific reset for TreeBuilder trait\n\n    this.CST_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n  };\n\n  return RecognizerEngine;\n}();\n\nexports.RecognizerEngine = RecognizerEngine;","map":null,"metadata":{},"sourceType":"script"}