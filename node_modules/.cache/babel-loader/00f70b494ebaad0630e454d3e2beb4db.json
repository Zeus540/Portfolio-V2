{"ast":null,"code":"import { TempNode } from '../core/TempNode.js';\nimport { FloatNode } from '../inputs/FloatNode.js';\nimport { TextureCubeUVNode } from './TextureCubeUVNode.js';\nimport { ReflectNode } from '../accessors/ReflectNode.js';\nimport { NormalNode } from '../accessors/NormalNode.js';\n\nfunction TextureCubeNode(value, uv, bias) {\n  TempNode.call(this, 'v4');\n  this.value = value;\n  this.radianceNode = new TextureCubeUVNode(this.value, uv || new ReflectNode(ReflectNode.VECTOR), // bias should be replaced in builder.context in build process\n  bias);\n  this.irradianceNode = new TextureCubeUVNode(this.value, new NormalNode(NormalNode.WORLD), new FloatNode(1).setReadonly(true));\n}\n\nTextureCubeNode.prototype = Object.create(TempNode.prototype);\nTextureCubeNode.prototype.constructor = TextureCubeNode;\nTextureCubeNode.prototype.nodeType = 'TextureCube';\n\nTextureCubeNode.prototype.generate = function (builder, output) {\n  if (builder.isShader('fragment')) {\n    builder.require('irradiance');\n\n    if (builder.context.bias) {\n      builder.context.bias.setTexture(this.value);\n    }\n\n    var scopeNode = builder.slot === 'irradiance' ? this.irradianceNode : this.radianceNode;\n    return scopeNode.build(builder, output);\n  } else {\n    console.warn('THREE.TextureCubeNode is not compatible with ' + builder.shader + ' shader.');\n    return builder.format('vec4( 0.0 )', this.getType(builder), output);\n  }\n};\n\nTextureCubeNode.prototype.copy = function (source) {\n  TempNode.prototype.copy.call(this, source);\n  this.value = source.value;\n  return this;\n};\n\nTextureCubeNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.value = this.value.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n\nexport { TextureCubeNode };","map":null,"metadata":{},"sourceType":"module"}