{"ast":null,"code":"import _slicedToArray from \"/home/zeus/Personal/Portfolio-V2/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { useThree, useFrame, context as context$1 } from '@react-three/fiber';\nimport mergeRefs from 'react-merge-refs';\nconst context =\n/*#__PURE__*/\nReact.createContext(null);\n\nfunction useScroll() {\n  return React.useContext(context);\n}\n\nfunction ScrollControls({\n  eps = 0.00001,\n  enabled = true,\n  infinite,\n  horizontal,\n  pages = 1,\n  distance = 1,\n  damping = 4,\n  style = {},\n  children\n}) {\n  const _useThree = useThree(),\n        gl = _useThree.gl,\n        size = _useThree.size,\n        invalidate = _useThree.invalidate,\n        events = _useThree.events,\n        raycaster = _useThree.raycaster;\n\n  const _React$useState = React.useState(() => document.createElement('div')),\n        _React$useState2 = _slicedToArray(_React$useState, 1),\n        el = _React$useState2[0];\n\n  const _React$useState3 = React.useState(() => document.createElement('div')),\n        _React$useState4 = _slicedToArray(_React$useState3, 1),\n        fill = _React$useState4[0];\n\n  const _React$useState5 = React.useState(() => document.createElement('div')),\n        _React$useState6 = _slicedToArray(_React$useState5, 1),\n        fixed = _React$useState6[0];\n\n  const target = gl.domElement.parentNode;\n  const scroll = React.useRef(0);\n  const state = React.useMemo(() => {\n    const state = {\n      el,\n      eps,\n      fill,\n      fixed,\n      horizontal,\n      damping,\n      offset: 0,\n      delta: 0,\n      scroll,\n      pages,\n\n      // 0-1 for a range between from -> from + distance\n      range(from, distance, margin = 0) {\n        const start = from - margin;\n        const end = start + distance + margin * 2;\n        return this.offset < start ? 0 : this.offset > end ? 1 : (this.offset - start) / (end - start);\n      },\n\n      // 0-1-0 for a range between from -> from + distance\n      curve(from, distance, margin = 0) {\n        return Math.sin(this.range(from, distance, margin) * Math.PI);\n      },\n\n      // true/false for a range between from -> from + distance\n      visible(from, distance, margin = 0) {\n        const start = from - margin;\n        const end = start + distance + margin * 2;\n        return this.offset >= start && this.offset <= end;\n      }\n\n    };\n    return state;\n  }, [eps, damping, horizontal, pages]);\n  React.useEffect(() => {\n    el.style.position = 'absolute';\n    el.style.width = '100%';\n    el.style.height = '100%';\n    el.style[horizontal ? 'overflowX' : 'overflowY'] = 'auto';\n    el.style[horizontal ? 'overflowY' : 'overflowX'] = 'hidden';\n    el.style.top = '0px';\n    el.style.left = '0px';\n\n    for (const key in style) {\n      el.style[key] = style[key];\n    }\n\n    fixed.style.position = 'sticky';\n    fixed.style.top = '0px';\n    fixed.style.left = '0px';\n    fixed.style.width = '100%';\n    fixed.style.height = '100%';\n    fixed.style.overflow = 'hidden';\n    el.appendChild(fixed);\n    fill.style.height = horizontal ? '100%' : `${pages * distance * 100}%`;\n    fill.style.width = horizontal ? `${pages * distance * 100}%` : '100%';\n    fill.style.pointerEvents = 'none';\n    el.appendChild(fill);\n    target.appendChild(el); // Init scroll one pixel in to allow upward/leftward scroll\n\n    el[horizontal ? 'scrollLeft' : 'scrollTop'] = 1;\n    const oldTarget = typeof events.connected !== 'boolean' ? events.connected : gl.domElement;\n    requestAnimationFrame(() => events.connect == null ? void 0 : events.connect(el));\n    const oldCompute = raycaster.computeOffsets;\n\n    raycaster.computeOffsets = ({\n      clientX,\n      clientY\n    }) => ({\n      offsetX: clientX - target.offsetLeft,\n      offsetY: clientY - target.offsetTop\n    });\n\n    return () => {\n      target.removeChild(el);\n      raycaster.computeOffsets = oldCompute;\n      events.connect == null ? void 0 : events.connect(oldTarget);\n    };\n  }, [pages, distance, horizontal, el, fill, fixed, target]);\n  React.useEffect(() => {\n    const containerLength = size[horizontal ? 'width' : 'height'];\n    const scrollLength = el[horizontal ? 'scrollWidth' : 'scrollHeight'];\n    const scrollThreshold = scrollLength - containerLength;\n    let current = 0;\n    let disableScroll = true;\n    let firstRun = true;\n\n    const onScroll = () => {\n      // Prevent first scroll because it is indirectly caused by the one pixel offset\n      if (!enabled || firstRun) return;\n      invalidate();\n      current = el[horizontal ? 'scrollLeft' : 'scrollTop'];\n      scroll.current = current / scrollThreshold;\n\n      if (infinite) {\n        if (!disableScroll) {\n          if (current >= scrollThreshold) {\n            const damp = 1 - state.offset;\n            el[horizontal ? 'scrollLeft' : 'scrollTop'] = 1;\n            scroll.current = state.offset = -damp;\n            disableScroll = true;\n          } else if (current <= 0) {\n            const damp = 1 + state.offset;\n            el[horizontal ? 'scrollLeft' : 'scrollTop'] = scrollLength;\n            scroll.current = state.offset = damp;\n            disableScroll = true;\n          }\n        }\n\n        if (disableScroll) setTimeout(() => disableScroll = false, 40);\n      }\n    };\n\n    el.addEventListener('scroll', onScroll, {\n      passive: true\n    });\n    requestAnimationFrame(() => firstRun = false);\n\n    const onWheel = e => el.scrollLeft += e.deltaY / 2;\n\n    if (horizontal) el.addEventListener('wheel', onWheel, {\n      passive: true\n    });\n    return () => {\n      el.removeEventListener('scroll', onScroll);\n      if (horizontal) el.removeEventListener('wheel', onWheel);\n    };\n  }, [el, size, infinite, state, invalidate, horizontal]);\n  let last = 0;\n  useFrame((_, delta) => {\n    state.offset = THREE.MathUtils.damp(last = state.offset, scroll.current, damping, delta);\n    state.delta = THREE.MathUtils.damp(state.delta, Math.abs(last - state.offset), damping, delta);\n    if (state.delta > eps) invalidate();\n  });\n  return (\n    /*#__PURE__*/\n    React.createElement(context.Provider, {\n      value: state\n    }, children)\n  );\n}\n\nconst ScrollCanvas =\n/*#__PURE__*/\nReact.forwardRef(({\n  children\n}, ref) => {\n  const group = React.useRef(null);\n  const state = useScroll();\n\n  const _useThree2 = useThree(state => state.viewport),\n        width = _useThree2.width,\n        height = _useThree2.height;\n\n  useFrame(() => {\n    group.current.position.x = state.horizontal ? -width * (state.pages - 1) * state.offset : 0;\n    group.current.position.y = state.horizontal ? 0 : height * (state.pages - 1) * state.offset;\n  });\n  return (\n    /*#__PURE__*/\n    React.createElement(\"group\", {\n      ref: mergeRefs([ref, group])\n    }, children)\n  );\n});\nconst ScrollHtml =\n/*#__PURE__*/\nReact.forwardRef(({\n  children,\n  style,\n  ...props\n}, ref) => {\n  const state = useScroll();\n  const group = React.useRef(null);\n\n  const _useThree3 = useThree(state => state.size),\n        width = _useThree3.width,\n        height = _useThree3.height;\n\n  const fiberState = React.useContext(context$1);\n  useFrame(() => {\n    if (state.delta > state.eps) {\n      group.current.style.transform = `translate3d(${state.horizontal ? -width * (state.pages - 1) * state.offset : 0}px,${state.horizontal ? 0 : height * (state.pages - 1) * -state.offset}px,0)`;\n    }\n  });\n  ReactDOM.render(\n  /*#__PURE__*/\n  React.createElement(\"div\", _extends({\n    ref: mergeRefs([ref, group]),\n    style: { ...style,\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      willChange: 'transform'\n    }\n  }, props),\n  /*#__PURE__*/\n  React.createElement(context.Provider, {\n    value: state\n  },\n  /*#__PURE__*/\n  React.createElement(context$1.Provider, {\n    value: fiberState\n  }, children))), state.fixed);\n  return null;\n});\nconst Scroll =\n/*#__PURE__*/\nReact.forwardRef(({\n  html,\n  ...props\n}, ref) => {\n  const El = html ? ScrollHtml : ScrollCanvas;\n  return (\n    /*#__PURE__*/\n    React.createElement(El, _extends({\n      ref: ref\n    }, props))\n  );\n});\nexport { Scroll, ScrollControls, useScroll };","map":null,"metadata":{},"sourceType":"module"}