{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GastRecorder = void 0;\n\nvar utils_1 = require(\"@chevrotain/utils\");\n\nvar gast_public_1 = require(\"../../grammar/gast/gast_public\");\n\nvar lexer_public_1 = require(\"../../../scan/lexer_public\");\n\nvar tokens_1 = require(\"../../../scan/tokens\");\n\nvar tokens_public_1 = require(\"../../../scan/tokens_public\");\n\nvar parser_1 = require(\"../parser\");\n\nvar keys_1 = require(\"../../grammar/keys\");\n\nvar RECORDING_NULL_OBJECT = {\n  description: \"This Object indicates the Parser is during Recording Phase\"\n};\nObject.freeze(RECORDING_NULL_OBJECT);\nvar HANDLE_SEPARATOR = true;\nvar MAX_METHOD_IDX = Math.pow(2, keys_1.BITS_FOR_OCCURRENCE_IDX) - 1;\nvar RFT = (0, tokens_public_1.createToken)({\n  name: \"RECORDING_PHASE_TOKEN\",\n  pattern: lexer_public_1.Lexer.NA\n});\n(0, tokens_1.augmentTokenTypes)([RFT]);\nvar RECORDING_PHASE_TOKEN = (0, tokens_public_1.createTokenInstance)(RFT, \"This IToken indicates the Parser is in Recording Phase\\n\\t\" + \"\" + \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\", // Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n-1, -1, -1, -1, -1, -1);\nObject.freeze(RECORDING_PHASE_TOKEN);\nvar RECORDING_PHASE_CSTNODE = {\n  name: \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" + \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  children: {}\n};\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\n\nvar GastRecorder =\n/** @class */\nfunction () {\n  function GastRecorder() {}\n\n  GastRecorder.prototype.initGastRecorder = function (config) {\n    this.recordingProdStack = [];\n    this.RECORDING_PHASE = false;\n  };\n\n  GastRecorder.prototype.enableRecording = function () {\n    var _this = this;\n\n    this.RECORDING_PHASE = true;\n    this.TRACE_INIT(\"Enable Recording\", function () {\n      var _loop_1 = function (i) {\n        var idx = i > 0 ? i : \"\";\n\n        _this[\"CONSUME\" + idx] = function (arg1, arg2) {\n          return this.consumeInternalRecord(arg1, i, arg2);\n        };\n\n        _this[\"SUBRULE\" + idx] = function (arg1, arg2) {\n          return this.subruleInternalRecord(arg1, i, arg2);\n        };\n\n        _this[\"OPTION\" + idx] = function (arg1) {\n          return this.optionInternalRecord(arg1, i);\n        };\n\n        _this[\"OR\" + idx] = function (arg1) {\n          return this.orInternalRecord(arg1, i);\n        };\n\n        _this[\"MANY\" + idx] = function (arg1) {\n          this.manyInternalRecord(i, arg1);\n        };\n\n        _this[\"MANY_SEP\" + idx] = function (arg1) {\n          this.manySepFirstInternalRecord(i, arg1);\n        };\n\n        _this[\"AT_LEAST_ONE\" + idx] = function (arg1) {\n          this.atLeastOneInternalRecord(i, arg1);\n        };\n\n        _this[\"AT_LEAST_ONE_SEP\" + idx] = function (arg1) {\n          this.atLeastOneSepFirstInternalRecord(i, arg1);\n        };\n      };\n      /**\n       * Warning Dark Voodoo Magic upcoming!\n       * We are \"replacing\" the public parsing DSL methods API\n       * With **new** alternative implementations on the Parser **instance**\n       *\n       * So far this is the only way I've found to avoid performance regressions during parsing time.\n       * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n       *   implementations directly instead.\n       */\n\n\n      for (var i = 0; i < 10; i++) {\n        _loop_1(i);\n      } // DSL methods with the idx(suffix) as an argument\n\n\n      _this[\"consume\"] = function (idx, arg1, arg2) {\n        return this.consumeInternalRecord(arg1, idx, arg2);\n      };\n\n      _this[\"subrule\"] = function (idx, arg1, arg2) {\n        return this.subruleInternalRecord(arg1, idx, arg2);\n      };\n\n      _this[\"option\"] = function (idx, arg1) {\n        return this.optionInternalRecord(arg1, idx);\n      };\n\n      _this[\"or\"] = function (idx, arg1) {\n        return this.orInternalRecord(arg1, idx);\n      };\n\n      _this[\"many\"] = function (idx, arg1) {\n        this.manyInternalRecord(idx, arg1);\n      };\n\n      _this[\"atLeastOne\"] = function (idx, arg1) {\n        this.atLeastOneInternalRecord(idx, arg1);\n      };\n\n      _this.ACTION = _this.ACTION_RECORD;\n      _this.BACKTRACK = _this.BACKTRACK_RECORD;\n      _this.LA = _this.LA_RECORD;\n    });\n  };\n\n  GastRecorder.prototype.disableRecording = function () {\n    var _this = this;\n\n    this.RECORDING_PHASE = false; // By deleting these **instance** properties, any future invocation\n    // will be deferred to the original methods on the **prototype** object\n    // This seems to get rid of any incorrect optimizations that V8 may\n    // do during the recording phase.\n\n    this.TRACE_INIT(\"Deleting Recording methods\", function () {\n      for (var i = 0; i < 10; i++) {\n        var idx = i > 0 ? i : \"\";\n        delete _this[\"CONSUME\" + idx];\n        delete _this[\"SUBRULE\" + idx];\n        delete _this[\"OPTION\" + idx];\n        delete _this[\"OR\" + idx];\n        delete _this[\"MANY\" + idx];\n        delete _this[\"MANY_SEP\" + idx];\n        delete _this[\"AT_LEAST_ONE\" + idx];\n        delete _this[\"AT_LEAST_ONE_SEP\" + idx];\n      }\n\n      delete _this[\"consume\"];\n      delete _this[\"subrule\"];\n      delete _this[\"option\"];\n      delete _this[\"or\"];\n      delete _this[\"many\"];\n      delete _this[\"atLeastOne\"];\n      delete _this.ACTION;\n      delete _this.BACKTRACK;\n      delete _this.LA;\n    });\n  }; // TODO: is there any way to use this method to check no\n  //   Parser methods are called inside an ACTION?\n  //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n\n\n  GastRecorder.prototype.ACTION_RECORD = function (impl) {\n    // NO-OP during recording\n    return;\n  }; // Executing backtracking logic will break our recording logic assumptions\n\n\n  GastRecorder.prototype.BACKTRACK_RECORD = function (grammarRule, args) {\n    return function () {\n      return true;\n    };\n  }; // LA is part of the official API and may be used for custom lookahead logic\n  // by end users who may forget to wrap it in ACTION or inside a GATE\n\n\n  GastRecorder.prototype.LA_RECORD = function (howMuch) {\n    // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n    // On LA return EOF at the end of the input so an infinite loop may occur.\n    return parser_1.END_OF_FILE;\n  };\n\n  GastRecorder.prototype.topLevelRuleRecord = function (name, def) {\n    try {\n      var newTopLevelRule = new gast_public_1.Rule({\n        definition: [],\n        name: name\n      });\n      newTopLevelRule.name = name;\n      this.recordingProdStack.push(newTopLevelRule);\n      def.call(this);\n      this.recordingProdStack.pop();\n      return newTopLevelRule;\n    } catch (originalError) {\n      if (originalError.KNOWN_RECORDER_ERROR !== true) {\n        try {\n          originalError.message = originalError.message + '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' + \"https://chevrotain.io/docs/guide/internals.html#grammar-recording\";\n        } catch (mutabilityError) {\n          // We may not be able to modify the original error object\n          throw originalError;\n        }\n      }\n\n      throw originalError;\n    }\n  }; // Implementation of parsing DSL\n\n\n  GastRecorder.prototype.optionInternalRecord = function (actionORMethodDef, occurrence) {\n    return recordProd.call(this, gast_public_1.Option, actionORMethodDef, occurrence);\n  };\n\n  GastRecorder.prototype.atLeastOneInternalRecord = function (occurrence, actionORMethodDef) {\n    recordProd.call(this, gast_public_1.RepetitionMandatory, actionORMethodDef, occurrence);\n  };\n\n  GastRecorder.prototype.atLeastOneSepFirstInternalRecord = function (occurrence, options) {\n    recordProd.call(this, gast_public_1.RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n  };\n\n  GastRecorder.prototype.manyInternalRecord = function (occurrence, actionORMethodDef) {\n    recordProd.call(this, gast_public_1.Repetition, actionORMethodDef, occurrence);\n  };\n\n  GastRecorder.prototype.manySepFirstInternalRecord = function (occurrence, options) {\n    recordProd.call(this, gast_public_1.RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n  };\n\n  GastRecorder.prototype.orInternalRecord = function (altsOrOpts, occurrence) {\n    return recordOrProd.call(this, altsOrOpts, occurrence);\n  };\n\n  GastRecorder.prototype.subruleInternalRecord = function (ruleToCall, occurrence, options) {\n    assertMethodIdxIsValid(occurrence);\n\n    if (!ruleToCall || (0, utils_1.has)(ruleToCall, \"ruleName\") === false) {\n      var error = new Error(\"<SUBRULE\" + getIdxSuffix(occurrence) + \"> argument is invalid\" + (\" expecting a Parser method reference but got: <\" + JSON.stringify(ruleToCall) + \">\") + (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n\n    var prevProd = (0, utils_1.peek)(this.recordingProdStack);\n    var ruleName = ruleToCall[\"ruleName\"];\n    var newNoneTerminal = new gast_public_1.NonTerminal({\n      idx: occurrence,\n      nonTerminalName: ruleName,\n      label: options === null || options === void 0 ? void 0 : options.LABEL,\n      // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n      referencedRule: undefined\n    });\n    prevProd.definition.push(newNoneTerminal);\n    return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;\n  };\n\n  GastRecorder.prototype.consumeInternalRecord = function (tokType, occurrence, options) {\n    assertMethodIdxIsValid(occurrence);\n\n    if (!(0, tokens_1.hasShortKeyProperty)(tokType)) {\n      var error = new Error(\"<CONSUME\" + getIdxSuffix(occurrence) + \"> argument is invalid\" + (\" expecting a TokenType reference but got: <\" + JSON.stringify(tokType) + \">\") + (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n\n    var prevProd = (0, utils_1.peek)(this.recordingProdStack);\n    var newNoneTerminal = new gast_public_1.Terminal({\n      idx: occurrence,\n      terminalType: tokType,\n      label: options === null || options === void 0 ? void 0 : options.LABEL\n    });\n    prevProd.definition.push(newNoneTerminal);\n    return RECORDING_PHASE_TOKEN;\n  };\n\n  return GastRecorder;\n}();\n\nexports.GastRecorder = GastRecorder;\n\nfunction recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {\n  if (handleSep === void 0) {\n    handleSep = false;\n  }\n\n  assertMethodIdxIsValid(occurrence);\n  var prevProd = (0, utils_1.peek)(this.recordingProdStack);\n  var grammarAction = (0, utils_1.isFunction)(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n  var newProd = new prodConstructor({\n    definition: [],\n    idx: occurrence\n  });\n\n  if (handleSep) {\n    newProd.separator = mainProdArg.SEP;\n  }\n\n  if ((0, utils_1.has)(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n\n  this.recordingProdStack.push(newProd);\n  grammarAction.call(this);\n  prevProd.definition.push(newProd);\n  this.recordingProdStack.pop();\n  return RECORDING_NULL_OBJECT;\n}\n\nfunction recordOrProd(mainProdArg, occurrence) {\n  var _this = this;\n\n  assertMethodIdxIsValid(occurrence);\n  var prevProd = (0, utils_1.peek)(this.recordingProdStack); // Only an array of alternatives\n\n  var hasOptions = (0, utils_1.isArray)(mainProdArg) === false;\n  var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n  var newOrProd = new gast_public_1.Alternation({\n    definition: [],\n    idx: occurrence,\n    ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n  });\n\n  if ((0, utils_1.has)(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n\n  var hasPredicates = (0, utils_1.some)(alts, function (currAlt) {\n    return (0, utils_1.isFunction)(currAlt.GATE);\n  });\n  newOrProd.hasPredicates = hasPredicates;\n  prevProd.definition.push(newOrProd);\n  (0, utils_1.forEach)(alts, function (currAlt) {\n    var currAltFlat = new gast_public_1.Alternative({\n      definition: []\n    });\n    newOrProd.definition.push(currAltFlat);\n\n    if ((0, utils_1.has)(currAlt, \"IGNORE_AMBIGUITIES\")) {\n      currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;\n    } // **implicit** ignoreAmbiguities due to usage of gate\n    else if ((0, utils_1.has)(currAlt, \"GATE\")) {\n        currAltFlat.ignoreAmbiguities = true;\n      }\n\n    _this.recordingProdStack.push(currAltFlat);\n\n    currAlt.ALT.call(_this);\n\n    _this.recordingProdStack.pop();\n  });\n  return RECORDING_NULL_OBJECT;\n}\n\nfunction getIdxSuffix(idx) {\n  return idx === 0 ? \"\" : \"\" + idx;\n}\n\nfunction assertMethodIdxIsValid(idx) {\n  if (idx < 0 || idx > MAX_METHOD_IDX) {\n    var error = new Error( // The stack trace will contain all the needed details\n    \"Invalid DSL Method idx value: <\" + idx + \">\\n\\t\" + (\"Idx value must be a none negative value smaller than \" + (MAX_METHOD_IDX + 1)));\n    error.KNOWN_RECORDER_ERROR = true;\n    throw error;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}