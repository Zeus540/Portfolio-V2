{"ast":null,"code":"import { Vector3, ParametricGeometry, BufferGeometry, Curve } from 'three';\n/**\n * Experimenting of primitive geometry creation using Surface Parametric equations\n */\n\nconst ParametricGeometries = {\n  klein: function (v, u, target) {\n    u *= Math.PI;\n    v *= 2 * Math.PI;\n    u = u * 2;\n    let x, y, z;\n\n    if (u < Math.PI) {\n      x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(u) * Math.cos(v);\n      z = -8 * Math.sin(u) - 2 * (1 - Math.cos(u) / 2) * Math.sin(u) * Math.cos(v);\n    } else {\n      x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(v + Math.PI);\n      z = -8 * Math.sin(u);\n    }\n\n    y = -2 * (1 - Math.cos(u) / 2) * Math.sin(v);\n    target.set(x, y, z);\n  },\n  plane: function (width, height) {\n    return (u, v, target) => {\n      const x = u * width;\n      const y = 0;\n      const z = v * height;\n      target.set(x, y, z);\n    };\n  },\n  mobius: function (u, t, target) {\n    // flat mobius strip\n    // http://www.wolframalpha.com/input/?i=M%C3%B6bius+strip+parametric+equations&lk=1&a=ClashPrefs_*Surface.MoebiusStrip.SurfaceProperty.ParametricEquations-\n    u = u - 0.5;\n    const v = 2 * Math.PI * t;\n    let x, y, z;\n    const a = 2;\n    x = Math.cos(v) * (a + u * Math.cos(v / 2));\n    y = Math.sin(v) * (a + u * Math.cos(v / 2));\n    z = u * Math.sin(v / 2);\n    target.set(x, y, z);\n  },\n  mobius3d: function (u, t, target) {\n    // volumetric mobius strip\n    u *= Math.PI;\n    t *= 2 * Math.PI;\n    u = u * 2;\n    const phi = u / 2;\n    const major = 2.25,\n          a = 0.125,\n          b = 0.65;\n    let x, y, z;\n    x = a * Math.cos(t) * Math.cos(phi) - b * Math.sin(t) * Math.sin(phi);\n    z = a * Math.cos(t) * Math.sin(phi) + b * Math.sin(t) * Math.cos(phi);\n    y = (major + x) * Math.sin(u);\n    x = (major + x) * Math.cos(u);\n    target.set(x, y, z);\n  }\n};\n/*********************************************\n *\n * Parametric Replacement for TubeGeometry\n *\n *********************************************/\n\nParametricGeometries.TubeGeometry = function (path, segments, radius, segmentsRadius, closed) {\n  this.path = path;\n  this.segments = segments || 64;\n  this.radius = radius || 1;\n  this.segmentsRadius = segmentsRadius || 8;\n  this.closed = closed || false;\n  const scope = this,\n        numpoints = this.segments + 1;\n  const frames = path.computeFrenetFrames(segments, closed),\n        tangents = frames.tangents,\n        normals = frames.normals,\n        binormals = frames.binormals; // proxy internals\n\n  this.tangents = tangents;\n  this.normals = normals;\n  this.binormals = binormals;\n  const position = new Vector3();\n\n  const ParametricTube = (u, v, target) => {\n    v *= 2 * Math.PI;\n    let i = u * (numpoints - 1);\n    i = Math.floor(i);\n    path.getPointAt(u, position);\n    const normal = normals[i];\n    const binormal = binormals[i];\n    const cx = -scope.radius * Math.cos(v); // TODO: Hack: Negating it so it faces outside.\n\n    const cy = scope.radius * Math.sin(v);\n    position.x += cx * normal.x + cy * binormal.x;\n    position.y += cx * normal.y + cy * binormal.y;\n    position.z += cx * normal.z + cy * binormal.z;\n    target.copy(position);\n  };\n\n  ParametricGeometry.call(this, ParametricTube, segments, segmentsRadius);\n};\n\nParametricGeometries.TubeGeometry.prototype = Object.create(BufferGeometry.prototype);\nParametricGeometries.TubeGeometry.prototype.constructor = ParametricGeometries.TubeGeometry;\n/*********************************************\n *\n * Parametric Replacement for TorusKnotGeometry\n *\n *********************************************/\n\nParametricGeometries.TorusKnotGeometry = function (radius, tube, segmentsT, segmentsR, p, q) {\n  this.radius = radius || 200;\n  this.tube = tube || 40;\n  this.segmentsT = segmentsT || 64;\n  this.segmentsR = segmentsR || 8;\n  this.p = p || 2;\n  this.q = q || 3;\n\n  class TorusKnotCurve extends Curve {\n    constructor() {\n      super();\n    }\n\n    getPoint(t, optionalTarget) {\n      const point = optionalTarget || new Vector3();\n      t *= Math.PI * 2;\n      const r = 0.5;\n      const x = (1 + r * Math.cos(q * t)) * Math.cos(p * t);\n      const y = (1 + r * Math.cos(q * t)) * Math.sin(p * t);\n      const z = r * Math.sin(q * t);\n      return point.set(x, y, z).multiplyScalar(radius);\n    }\n\n  }\n\n  const segments = segmentsT;\n  const radiusSegments = segmentsR;\n  const extrudePath = new TorusKnotCurve();\n  ParametricGeometries.TubeGeometry.call(this, extrudePath, segments, tube, radiusSegments, true, false);\n};\n\nParametricGeometries.TorusKnotGeometry.prototype = Object.create(BufferGeometry.prototype);\nParametricGeometries.TorusKnotGeometry.prototype.constructor = ParametricGeometries.TorusKnotGeometry;\n/*********************************************\n *\n * Parametric Replacement for SphereGeometry\n *\n *********************************************/\n\nParametricGeometries.SphereGeometry = function (size, u, v) {\n  function sphere(u, v, target) {\n    u *= Math.PI;\n    v *= 2 * Math.PI;\n    const x = size * Math.sin(u) * Math.cos(v);\n    const y = size * Math.sin(u) * Math.sin(v);\n    const z = size * Math.cos(u);\n    target.set(x, y, z);\n  }\n\n  ParametricGeometry.call(this, sphere, u, v);\n};\n\nParametricGeometries.SphereGeometry.prototype = Object.create(BufferGeometry.prototype);\nParametricGeometries.SphereGeometry.prototype.constructor = ParametricGeometries.SphereGeometry;\n/*********************************************\n *\n * Parametric Replacement for PlaneGeometry\n *\n *********************************************/\n\nParametricGeometries.PlaneGeometry = function (width, depth, segmentsWidth, segmentsDepth) {\n  function plane(u, v, target) {\n    const x = u * width;\n    const y = 0;\n    const z = v * depth;\n    target.set(x, y, z);\n  }\n\n  ParametricGeometry.call(this, plane, segmentsWidth, segmentsDepth);\n};\n\nParametricGeometries.PlaneGeometry.prototype = Object.create(BufferGeometry.prototype);\nParametricGeometries.PlaneGeometry.prototype.constructor = ParametricGeometries.PlaneGeometry;\nexport { ParametricGeometries };","map":null,"metadata":{},"sourceType":"module"}