{"ast":null,"code":"import { TempNode } from './TempNode.js';\nimport { NodeLib } from './NodeLib.js';\nvar declarationRegexp = /^\\s*([a-z_0-9]+)\\s([a-z_0-9]+)\\s*\\((.*?)\\)/i,\n    propertiesRegexp = /[a-z_0-9]+/gi;\n\nfunction FunctionNode(src, includes, extensions, keywords, type) {\n  this.isMethod = type === undefined;\n  this.isInterface = false;\n  TempNode.call(this, type);\n  this.parse(src, includes, extensions, keywords);\n}\n\nFunctionNode.prototype = Object.create(TempNode.prototype);\nFunctionNode.prototype.constructor = FunctionNode;\nFunctionNode.prototype.nodeType = 'Function';\nFunctionNode.prototype.useKeywords = true;\n\nFunctionNode.prototype.getShared = function ()\n/* builder, output */\n{\n  return !this.isMethod;\n};\n\nFunctionNode.prototype.getType = function (builder) {\n  return builder.getTypeByFormat(this.type);\n};\n\nFunctionNode.prototype.getInputByName = function (name) {\n  var i = this.inputs.length;\n\n  while (i--) {\n    if (this.inputs[i].name === name) {\n      return this.inputs[i];\n    }\n  }\n};\n\nFunctionNode.prototype.getIncludeByName = function (name) {\n  var i = this.includes.length;\n\n  while (i--) {\n    if (this.includes[i].name === name) {\n      return this.includes[i];\n    }\n  }\n};\n\nFunctionNode.prototype.generate = function (builder, output) {\n  var match,\n      offset = 0,\n      src = this.src;\n\n  for (let i = 0; i < this.includes.length; i++) {\n    builder.include(this.includes[i], this);\n  }\n\n  for (let ext in this.extensions) {\n    builder.extensions[ext] = true;\n  }\n\n  var matches = [];\n\n  while (match = propertiesRegexp.exec(this.src)) matches.push(match);\n\n  for (let i = 0; i < matches.length; i++) {\n    var match = matches[i];\n    var prop = match[0],\n        isGlobal = this.isMethod ? !this.getInputByName(prop) : true,\n        reference = prop;\n\n    if (this.keywords[prop] || this.useKeywords && isGlobal && NodeLib.containsKeyword(prop)) {\n      var node = this.keywords[prop];\n\n      if (!node) {\n        var keyword = NodeLib.getKeywordData(prop);\n        if (keyword.cache) node = builder.keywords[prop];\n        node = node || NodeLib.getKeyword(prop, builder);\n        if (keyword.cache) builder.keywords[prop] = node;\n      }\n\n      reference = node.build(builder);\n    }\n\n    if (prop !== reference) {\n      src = src.substring(0, match.index + offset) + reference + src.substring(match.index + prop.length + offset);\n      offset += reference.length - prop.length;\n    }\n\n    if (this.getIncludeByName(reference) === undefined && NodeLib.contains(reference)) {\n      builder.include(NodeLib.get(reference));\n    }\n  }\n\n  if (output === 'source') {\n    return src;\n  } else if (this.isMethod) {\n    if (!this.isInterface) {\n      builder.include(this, false, src);\n    }\n\n    return this.name;\n  } else {\n    return builder.format('( ' + src + ' )', this.getType(builder), output);\n  }\n};\n\nFunctionNode.prototype.parse = function (src, includes, extensions, keywords) {\n  this.src = src || '';\n  this.includes = includes || [];\n  this.extensions = extensions || {};\n  this.keywords = keywords || {};\n\n  if (this.isMethod) {\n    var match = this.src.match(declarationRegexp);\n    this.inputs = [];\n\n    if (match && match.length == 4) {\n      this.type = match[1];\n      this.name = match[2];\n      var inputs = match[3].match(propertiesRegexp);\n\n      if (inputs) {\n        var i = 0;\n\n        while (i < inputs.length) {\n          var qualifier = inputs[i++];\n          var type, name;\n\n          if (qualifier === 'in' || qualifier === 'out' || qualifier === 'inout') {\n            type = inputs[i++];\n          } else {\n            type = qualifier;\n            qualifier = '';\n          }\n\n          name = inputs[i++];\n          this.inputs.push({\n            name: name,\n            type: type,\n            qualifier: qualifier\n          });\n        }\n      }\n\n      this.isInterface = this.src.indexOf('{') === -1;\n    } else {\n      this.type = '';\n      this.name = '';\n    }\n  }\n};\n\nFunctionNode.prototype.copy = function (source) {\n  TempNode.prototype.copy.call(this, source);\n  this.isMethod = source.isMethod;\n  this.useKeywords = source.useKeywords;\n  this.parse(source.src, source.includes, source.extensions, source.keywords);\n  if (source.type !== undefined) this.type = source.type;\n  return this;\n};\n\nFunctionNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.src = this.src;\n    data.isMethod = this.isMethod;\n    data.useKeywords = this.useKeywords;\n    if (!this.isMethod) data.type = this.type;\n    data.extensions = JSON.parse(JSON.stringify(this.extensions));\n    data.keywords = {};\n\n    for (let keyword in this.keywords) {\n      data.keywords[keyword] = this.keywords[keyword].toJSON(meta).uuid;\n    }\n\n    if (this.includes.length) {\n      data.includes = [];\n\n      for (let i = 0; i < this.includes.length; i++) {\n        data.includes.push(this.includes[i].toJSON(meta).uuid);\n      }\n    }\n  }\n\n  return data;\n};\n\nexport { FunctionNode };","map":null,"metadata":{},"sourceType":"module"}