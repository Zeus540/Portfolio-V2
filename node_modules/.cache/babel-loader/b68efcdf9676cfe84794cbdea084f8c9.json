{"ast":null,"code":"import { TempNode } from '../core/TempNode.js';\nimport { PositionNode } from './PositionNode.js';\nimport { NormalNode } from './NormalNode.js';\n\nfunction ReflectNode(scope) {\n  TempNode.call(this, 'v3');\n  this.scope = scope || ReflectNode.CUBE;\n}\n\nReflectNode.CUBE = 'cube';\nReflectNode.SPHERE = 'sphere';\nReflectNode.VECTOR = 'vector';\nReflectNode.prototype = Object.create(TempNode.prototype);\nReflectNode.prototype.constructor = ReflectNode;\nReflectNode.prototype.nodeType = 'Reflect';\n\nReflectNode.prototype.getUnique = function (builder) {\n  return !builder.context.viewNormal;\n};\n\nReflectNode.prototype.getType = function ()\n/* builder */\n{\n  switch (this.scope) {\n    case ReflectNode.SPHERE:\n      return 'v2';\n  }\n\n  return this.type;\n};\n\nReflectNode.prototype.generate = function (builder, output) {\n  var isUnique = this.getUnique(builder);\n\n  if (builder.isShader('fragment')) {\n    var result;\n\n    switch (this.scope) {\n      case ReflectNode.VECTOR:\n        var viewNormalNode = new NormalNode(NormalNode.VIEW);\n        var roughnessNode = builder.context.roughness;\n        var viewNormal = viewNormalNode.build(builder, 'v3');\n        var viewPosition = new PositionNode(PositionNode.VIEW).build(builder, 'v3');\n        var roughness = roughnessNode ? roughnessNode.build(builder, 'f') : undefined;\n        var method = `reflect( -normalize( ${viewPosition} ), ${viewNormal} )`;\n\n        if (roughness) {\n          // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n          method = `normalize( mix( ${method}, ${viewNormal}, ${roughness} * ${roughness} ) )`;\n        }\n\n        var code = `inverseTransformDirection( ${method}, viewMatrix )`;\n\n        if (isUnique) {\n          builder.addNodeCode(`vec3 reflectVec = ${code};`);\n          result = 'reflectVec';\n        } else {\n          result = code;\n        }\n\n        break;\n\n      case ReflectNode.CUBE:\n        var reflectVec = new ReflectNode(ReflectNode.VECTOR).build(builder, 'v3');\n        var code = 'vec3( -' + reflectVec + '.x, ' + reflectVec + '.yz )';\n\n        if (isUnique) {\n          builder.addNodeCode(`vec3 reflectCubeVec = ${code};`);\n          result = 'reflectCubeVec';\n        } else {\n          result = code;\n        }\n\n        break;\n\n      case ReflectNode.SPHERE:\n        var reflectVec = new ReflectNode(ReflectNode.VECTOR).build(builder, 'v3');\n        var code = 'normalize( ( viewMatrix * vec4( ' + reflectVec + ', 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5';\n\n        if (isUnique) {\n          builder.addNodeCode(`vec2 reflectSphereVec = ${code};`);\n          result = 'reflectSphereVec';\n        } else {\n          result = code;\n        }\n\n        break;\n    }\n\n    return builder.format(result, this.getType(builder), output);\n  } else {\n    console.warn('THREE.ReflectNode is not compatible with ' + builder.shader + ' shader.');\n    return builder.format('vec3( 0.0 )', this.type, output);\n  }\n};\n\nReflectNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.scope = this.scope;\n  }\n\n  return data;\n};\n\nexport { ReflectNode };","map":null,"metadata":{},"sourceType":"module"}