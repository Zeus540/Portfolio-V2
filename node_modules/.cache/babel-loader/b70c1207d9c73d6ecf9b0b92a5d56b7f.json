{"ast":null,"code":"import _slicedToArray from \"/home/zeus/Personal/Portfolio-V2/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport * as React from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport { Color, Vector3, Spherical, AdditiveBlending, ShaderMaterial } from 'three';\n\nclass StarfieldMaterial extends ShaderMaterial {\n  constructor() {\n    super({\n      uniforms: {\n        time: {\n          value: 0.0\n        },\n        fade: {\n          value: 1.0\n        }\n      },\n      vertexShader:\n      /* glsl */\n      `\n      uniform float time;\n      attribute float size;\n      varying vec3 vColor;\n      void main() {\n        vColor = color;\n        vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);\n        gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(mvPosition.x + 2.0 * time + 100.0));\n        gl_Position = projectionMatrix * mvPosition;\n      }`,\n      fragmentShader:\n      /* glsl */\n      `\n      uniform sampler2D pointTexture;\n      uniform float fade;\n      varying vec3 vColor;\n      void main() {\n        float opacity = 1.0;\n        if (fade == 1.0) {\n          float d = distance(gl_PointCoord, vec2(0.5, 0.5));\n          opacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));\n        }\n        gl_FragColor = vec4(vColor, opacity);\n\n        #include <tonemapping_fragment>\n\t      #include <encodings_fragment>\n      }`\n    });\n  }\n\n}\n\nconst genStar = r => {\n  return new Vector3().setFromSpherical(new Spherical(r, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI));\n};\n\nconst Stars =\n/*#__PURE__*/\nReact.forwardRef(({\n  radius = 100,\n  depth = 50,\n  count = 5000,\n  saturation = 0,\n  factor = 4,\n  fade = false\n}, ref) => {\n  const material = React.useRef();\n\n  const _React$useMemo = React.useMemo(() => {\n    const positions = [];\n    const colors = [];\n    const sizes = Array.from({\n      length: count\n    }, () => (0.5 + 0.5 * Math.random()) * factor);\n    const color = new Color();\n    let r = radius + depth;\n    const increment = depth / count;\n\n    for (let i = 0; i < count; i++) {\n      r -= increment * Math.random();\n      positions.push(...genStar(r).toArray());\n      color.setHSL(i / count, saturation, 0.9);\n      colors.push(color.r, color.g, color.b);\n    }\n\n    return [new Float32Array(positions), new Float32Array(colors), new Float32Array(sizes)];\n  }, [count, depth, factor, radius, saturation]),\n        _React$useMemo2 = _slicedToArray(_React$useMemo, 3),\n        position = _React$useMemo2[0],\n        color = _React$useMemo2[1],\n        size = _React$useMemo2[2];\n\n  useFrame(state => material.current && (material.current.uniforms.time.value = state.clock.getElapsedTime()));\n\n  const _React$useState = React.useState(() => new StarfieldMaterial()),\n        _React$useState2 = _slicedToArray(_React$useState, 1),\n        starfieldMaterial = _React$useState2[0];\n\n  return (\n    /*#__PURE__*/\n    React.createElement(\"points\", {\n      ref: ref\n    },\n    /*#__PURE__*/\n    React.createElement(\"bufferGeometry\", {\n      attach: \"geometry\"\n    },\n    /*#__PURE__*/\n    React.createElement(\"bufferAttribute\", {\n      attachObject: ['attributes', 'position'],\n      args: [position, 3]\n    }),\n    /*#__PURE__*/\n    React.createElement(\"bufferAttribute\", {\n      attachObject: ['attributes', 'color'],\n      args: [color, 3]\n    }),\n    /*#__PURE__*/\n    React.createElement(\"bufferAttribute\", {\n      attachObject: ['attributes', 'size'],\n      args: [size, 1]\n    })),\n    /*#__PURE__*/\n    React.createElement(\"primitive\", {\n      dispose: undefined,\n      ref: material,\n      object: starfieldMaterial,\n      attach: \"material\",\n      blending: AdditiveBlending,\n      \"uniforms-fade-value\": fade,\n      transparent: true,\n      vertexColors: true\n    }))\n  );\n});\nexport { Stars };","map":null,"metadata":{},"sourceType":"module"}