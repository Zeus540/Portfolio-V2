{"ast":null,"code":"\"use strict\";\n/*\n Utils using lodash style API. (not necessarily 100% compliant) for functional and other utils.\n These utils should replace usage of lodash in the production code base. not because they are any better...\n but for the purpose of being a dependency free library.\n\n The hotspots in the code are already written in imperative style for performance reasons.\n so writing several dozen utils which may be slower than the original lodash, does not matter as much\n considering they will not be invoked in hotspots...\n */\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toFastProperties = exports.timer = exports.peek = exports.isES2015MapSupported = exports.PRINT_WARNING = exports.PRINT_ERROR = exports.packArray = exports.IDENTITY = exports.NOOP = exports.merge = exports.groupBy = exports.defaults = exports.assignNoOverwrite = exports.assign = exports.zipObject = exports.sortBy = exports.indexOf = exports.some = exports.difference = exports.every = exports.isObject = exports.isRegExp = exports.isArray = exports.partial = exports.uniq = exports.compact = exports.reduce = exports.findAll = exports.find = exports.cloneObj = exports.cloneArr = exports.contains = exports.has = exports.pick = exports.reject = exports.filter = exports.dropRight = exports.drop = exports.isFunction = exports.isUndefined = exports.isString = exports.forEach = exports.last = exports.first = exports.flatten = exports.map = exports.mapValues = exports.values = exports.keys = exports.isEmpty = void 0;\nexports.upperFirst = void 0;\n\nfunction isEmpty(arr) {\n  return arr && arr.length === 0;\n}\n\nexports.isEmpty = isEmpty;\n\nfunction keys(obj) {\n  if (obj === undefined || obj === null) {\n    return [];\n  }\n\n  return Object.keys(obj);\n}\n\nexports.keys = keys;\n\nfunction values(obj) {\n  var vals = [];\n  var keys = Object.keys(obj);\n\n  for (var i = 0; i < keys.length; i++) {\n    vals.push(obj[keys[i]]);\n  }\n\n  return vals;\n}\n\nexports.values = values;\n\nfunction mapValues(obj, callback) {\n  var result = [];\n  var objKeys = keys(obj);\n\n  for (var idx = 0; idx < objKeys.length; idx++) {\n    var currKey = objKeys[idx];\n    result.push(callback.call(null, obj[currKey], currKey));\n  }\n\n  return result;\n}\n\nexports.mapValues = mapValues;\n\nfunction map(arr, callback) {\n  var result = [];\n\n  for (var idx = 0; idx < arr.length; idx++) {\n    result.push(callback.call(null, arr[idx], idx));\n  }\n\n  return result;\n}\n\nexports.map = map;\n\nfunction flatten(arr) {\n  var result = [];\n\n  for (var idx = 0; idx < arr.length; idx++) {\n    var currItem = arr[idx];\n\n    if (Array.isArray(currItem)) {\n      result = result.concat(flatten(currItem));\n    } else {\n      result.push(currItem);\n    }\n  }\n\n  return result;\n}\n\nexports.flatten = flatten;\n\nfunction first(arr) {\n  return isEmpty(arr) ? undefined : arr[0];\n}\n\nexports.first = first;\n\nfunction last(arr) {\n  var len = arr && arr.length;\n  return len ? arr[len - 1] : undefined;\n}\n\nexports.last = last;\n\nfunction forEach(collection, iteratorCallback) {\n  /* istanbul ignore else */\n  if (Array.isArray(collection)) {\n    for (var i = 0; i < collection.length; i++) {\n      iteratorCallback.call(null, collection[i], i);\n    }\n  } else if (isObject(collection)) {\n    var colKeys = keys(collection);\n\n    for (var i = 0; i < colKeys.length; i++) {\n      var key = colKeys[i];\n      var value = collection[key];\n      iteratorCallback.call(null, value, key);\n    }\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nexports.forEach = forEach;\n\nfunction isString(item) {\n  return typeof item === \"string\";\n}\n\nexports.isString = isString;\n\nfunction isUndefined(item) {\n  return item === undefined;\n}\n\nexports.isUndefined = isUndefined;\n\nfunction isFunction(item) {\n  return item instanceof Function;\n}\n\nexports.isFunction = isFunction;\n\nfunction drop(arr, howMuch) {\n  if (howMuch === void 0) {\n    howMuch = 1;\n  }\n\n  return arr.slice(howMuch, arr.length);\n}\n\nexports.drop = drop;\n\nfunction dropRight(arr, howMuch) {\n  if (howMuch === void 0) {\n    howMuch = 1;\n  }\n\n  return arr.slice(0, arr.length - howMuch);\n}\n\nexports.dropRight = dropRight;\n\nfunction filter(arr, predicate) {\n  var result = [];\n\n  if (Array.isArray(arr)) {\n    for (var i = 0; i < arr.length; i++) {\n      var item = arr[i];\n\n      if (predicate.call(null, item)) {\n        result.push(item);\n      }\n    }\n  }\n\n  return result;\n}\n\nexports.filter = filter;\n\nfunction reject(arr, predicate) {\n  return filter(arr, function (item) {\n    return !predicate(item);\n  });\n}\n\nexports.reject = reject;\n\nfunction pick(obj, predicate) {\n  var keys = Object.keys(obj);\n  var result = {};\n\n  for (var i = 0; i < keys.length; i++) {\n    var currKey = keys[i];\n    var currItem = obj[currKey];\n\n    if (predicate(currItem)) {\n      result[currKey] = currItem;\n    }\n  }\n\n  return result;\n}\n\nexports.pick = pick;\n\nfunction has(obj, prop) {\n  if (isObject(obj)) {\n    return obj.hasOwnProperty(prop);\n  }\n\n  return false;\n}\n\nexports.has = has;\n\nfunction contains(arr, item) {\n  return find(arr, function (currItem) {\n    return currItem === item;\n  }) !== undefined ? true : false;\n}\n\nexports.contains = contains;\n/**\n * shallow clone\n */\n\nfunction cloneArr(arr) {\n  var newArr = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    newArr.push(arr[i]);\n  }\n\n  return newArr;\n}\n\nexports.cloneArr = cloneArr;\n/**\n * shallow clone\n */\n\nfunction cloneObj(obj) {\n  var clonedObj = {};\n\n  for (var key in obj) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      clonedObj[key] = obj[key];\n    }\n  }\n\n  return clonedObj;\n}\n\nexports.cloneObj = cloneObj;\n\nfunction find(arr, predicate) {\n  for (var i = 0; i < arr.length; i++) {\n    var item = arr[i];\n\n    if (predicate.call(null, item)) {\n      return item;\n    }\n  }\n\n  return undefined;\n}\n\nexports.find = find;\n\nfunction findAll(arr, predicate) {\n  var found = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    var item = arr[i];\n\n    if (predicate.call(null, item)) {\n      found.push(item);\n    }\n  }\n\n  return found;\n}\n\nexports.findAll = findAll;\n\nfunction reduce(arrOrObj, iterator, initial) {\n  var isArr = Array.isArray(arrOrObj);\n  var vals = isArr ? arrOrObj : values(arrOrObj);\n  var objKeys = isArr ? [] : keys(arrOrObj);\n  var accumulator = initial;\n\n  for (var i = 0; i < vals.length; i++) {\n    accumulator = iterator.call(null, accumulator, vals[i], isArr ? i : objKeys[i]);\n  }\n\n  return accumulator;\n}\n\nexports.reduce = reduce;\n\nfunction compact(arr) {\n  return reject(arr, function (item) {\n    return item === null || item === undefined;\n  });\n}\n\nexports.compact = compact;\n\nfunction uniq(arr, identity) {\n  if (identity === void 0) {\n    identity = function (item) {\n      return item;\n    };\n  }\n\n  var identities = [];\n  return reduce(arr, function (result, currItem) {\n    var currIdentity = identity(currItem);\n\n    if (contains(identities, currIdentity)) {\n      return result;\n    } else {\n      identities.push(currIdentity);\n      return result.concat(currItem);\n    }\n  }, []);\n}\n\nexports.uniq = uniq;\n\nfunction partial(func) {\n  var restArgs = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    restArgs[_i - 1] = arguments[_i];\n  }\n\n  var firstArg = [null];\n  var allArgs = firstArg.concat(restArgs);\n  return Function.bind.apply(func, allArgs);\n}\n\nexports.partial = partial;\n\nfunction isArray(obj) {\n  return Array.isArray(obj);\n}\n\nexports.isArray = isArray;\n\nfunction isRegExp(obj) {\n  return obj instanceof RegExp;\n}\n\nexports.isRegExp = isRegExp;\n\nfunction isObject(obj) {\n  return obj instanceof Object;\n}\n\nexports.isObject = isObject;\n\nfunction every(arr, predicate) {\n  for (var i = 0; i < arr.length; i++) {\n    if (!predicate(arr[i], i)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.every = every;\n\nfunction difference(arr, values) {\n  return reject(arr, function (item) {\n    return contains(values, item);\n  });\n}\n\nexports.difference = difference;\n\nfunction some(arr, predicate) {\n  for (var i = 0; i < arr.length; i++) {\n    if (predicate(arr[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexports.some = some;\n\nfunction indexOf(arr, value) {\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i] === value) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nexports.indexOf = indexOf;\n\nfunction sortBy(arr, orderFunc) {\n  var result = cloneArr(arr);\n  result.sort(function (a, b) {\n    return orderFunc(a) - orderFunc(b);\n  });\n  return result;\n}\n\nexports.sortBy = sortBy;\n\nfunction zipObject(keys, values) {\n  if (keys.length !== values.length) {\n    throw Error(\"can't zipObject with different number of keys and values!\");\n  }\n\n  var result = {};\n\n  for (var i = 0; i < keys.length; i++) {\n    result[keys[i]] = values[i];\n  }\n\n  return result;\n}\n\nexports.zipObject = zipObject;\n/**\n * mutates! (and returns) target\n */\n\nfunction assign(target) {\n  var sources = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    sources[_i - 1] = arguments[_i];\n  }\n\n  for (var i = 0; i < sources.length; i++) {\n    var curSource = sources[i];\n    var currSourceKeys = keys(curSource);\n\n    for (var j = 0; j < currSourceKeys.length; j++) {\n      var currKey = currSourceKeys[j];\n      target[currKey] = curSource[currKey];\n    }\n  }\n\n  return target;\n}\n\nexports.assign = assign;\n/**\n * mutates! (and returns) target\n */\n\nfunction assignNoOverwrite(target) {\n  var sources = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    sources[_i - 1] = arguments[_i];\n  }\n\n  for (var i = 0; i < sources.length; i++) {\n    var curSource = sources[i];\n    var currSourceKeys = keys(curSource);\n\n    for (var j = 0; j < currSourceKeys.length; j++) {\n      var currKey = currSourceKeys[j];\n\n      if (!has(target, currKey)) {\n        target[currKey] = curSource[currKey];\n      }\n    }\n  }\n\n  return target;\n}\n\nexports.assignNoOverwrite = assignNoOverwrite;\n\nfunction defaults() {\n  var sources = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    sources[_i] = arguments[_i];\n  }\n\n  return assignNoOverwrite.apply(void 0, __spreadArray([{}], sources, false));\n}\n\nexports.defaults = defaults;\n\nfunction groupBy(arr, groupKeyFunc) {\n  var result = {};\n  forEach(arr, function (item) {\n    var currGroupKey = groupKeyFunc(item);\n    var currGroupArr = result[currGroupKey];\n\n    if (currGroupArr) {\n      currGroupArr.push(item);\n    } else {\n      result[currGroupKey] = [item];\n    }\n  });\n  return result;\n}\n\nexports.groupBy = groupBy;\n/**\n * Merge obj2 into obj1.\n * Will overwrite existing properties with the same name\n */\n\nfunction merge(obj1, obj2) {\n  var result = cloneObj(obj1);\n  var keys2 = keys(obj2);\n\n  for (var i = 0; i < keys2.length; i++) {\n    var key = keys2[i];\n    var value = obj2[key];\n    result[key] = value;\n  }\n\n  return result;\n}\n\nexports.merge = merge;\n\nfunction NOOP() {}\n\nexports.NOOP = NOOP;\n\nfunction IDENTITY(item) {\n  return item;\n}\n\nexports.IDENTITY = IDENTITY;\n/**\n * Will return a new packed array with same values.\n */\n\nfunction packArray(holeyArr) {\n  var result = [];\n\n  for (var i = 0; i < holeyArr.length; i++) {\n    var orgValue = holeyArr[i];\n    result.push(orgValue !== undefined ? orgValue : undefined);\n  }\n\n  return result;\n}\n\nexports.packArray = packArray;\n\nfunction PRINT_ERROR(msg) {\n  /* istanbul ignore else - can't override global.console in node.js */\n  if (console && console.error) {\n    console.error(\"Error: \" + msg);\n  }\n}\n\nexports.PRINT_ERROR = PRINT_ERROR;\n\nfunction PRINT_WARNING(msg) {\n  /* istanbul ignore else - can't override global.console in node.js*/\n  if (console && console.warn) {\n    // TODO: modify docs accordingly\n    console.warn(\"Warning: \" + msg);\n  }\n}\n\nexports.PRINT_WARNING = PRINT_WARNING;\n\nfunction isES2015MapSupported() {\n  return typeof Map === \"function\";\n}\n\nexports.isES2015MapSupported = isES2015MapSupported;\n\nfunction peek(arr) {\n  return arr[arr.length - 1];\n}\n\nexports.peek = peek;\n/* istanbul ignore next - for performance tracing*/\n\nfunction timer(func) {\n  var start = new Date().getTime();\n  var val = func();\n  var end = new Date().getTime();\n  var total = end - start;\n  return {\n    time: total,\n    value: val\n  };\n}\n\nexports.timer = timer; // based on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216\n\nfunction toFastProperties(toBecomeFast) {\n  function FakeConstructor() {} // If our object is used as a constructor it would receive\n\n\n  FakeConstructor.prototype = toBecomeFast;\n  var fakeInstance = new FakeConstructor();\n\n  function fakeAccess() {\n    return typeof fakeInstance.bar;\n  } // help V8 understand this is a \"real\" prototype by actually using\n  // the fake instance.\n\n\n  fakeAccess();\n  fakeAccess();\n  return toBecomeFast; // Eval prevents optimization of this method (even though this is dead code)\n\n  /* istanbul ignore next */\n  // tslint:disable-next-line\n\n  eval(toBecomeFast);\n}\n\nexports.toFastProperties = toFastProperties;\n\nfunction upperFirst(str) {\n  if (!str) {\n    return str;\n  }\n\n  var firstChar = getCharacterFromCodePointAt(str, 0);\n  return firstChar.toUpperCase() + str.substring(firstChar.length);\n}\n\nexports.upperFirst = upperFirst;\nvar surrogatePairPattern = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/;\n\nfunction getCharacterFromCodePointAt(str, idx) {\n  var surrogatePairCandidate = str.substring(idx, idx + 1);\n  return surrogatePairPattern.test(surrogatePairCandidate) ? surrogatePairCandidate : str[idx];\n}","map":null,"metadata":{},"sourceType":"script"}