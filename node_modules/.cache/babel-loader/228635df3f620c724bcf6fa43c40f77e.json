{"ast":null,"code":"import _slicedToArray from \"/home/zeus/Personal/Portfolio-V2/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useFrame } from '@react-three/fiber';\nimport mergeRefs from 'react-merge-refs';\nimport { Position } from '../helpers/Position.js';\nlet i, positionRef;\nconst context =\n/*#__PURE__*/\nReact.createContext(null);\nconst parentMatrix = new THREE.Matrix4();\nconst position = new THREE.Vector3();\nconst color = new THREE.Color();\n/**\n * Instance implementation, relies on react + context to update the attributes based on the children of this component\n */\n\nconst PointsInstances =\n/*#__PURE__*/\nReact.forwardRef(({\n  children,\n  range,\n  limit = 1000,\n  ...props\n}, ref) => {\n  const parentRef = React.useRef(null);\n\n  const _React$useState = React.useState([]),\n        _React$useState2 = _slicedToArray(_React$useState, 2),\n        refs = _React$useState2[0],\n        setRefs = _React$useState2[1];\n\n  const _React$useState3 = React.useState(() => [new Float32Array(limit * 3), Float32Array.from({\n    length: limit * 3\n  }, () => 1), Float32Array.from({\n    length: limit\n  }, () => 1)]),\n        _React$useState4 = _slicedToArray(_React$useState3, 1),\n        _React$useState4$ = _slicedToArray(_React$useState4[0], 3),\n        positions = _React$useState4$[0],\n        colors = _React$useState4$[1],\n        sizes = _React$useState4$[2];\n\n  React.useLayoutEffect(() => {\n    parentRef.current.geometry.drawRange.count = Math.min(limit, range !== undefined ? range : limit, refs.length);\n  }, [refs, range]);\n  React.useEffect(() => {\n    // We might be a frame too late? 🤷‍♂️\n    parentRef.current.geometry.attributes.position.needsUpdate = true;\n  });\n  useFrame(() => {\n    parentRef.current.updateMatrix();\n    parentRef.current.updateMatrixWorld();\n    parentMatrix.copy(parentRef.current.matrixWorld).invert();\n\n    for (i = 0; i < refs.length; i++) {\n      positionRef = refs[i].current;\n      positionRef.getWorldPosition(position).applyMatrix4(parentMatrix);\n\n      if (position.x !== positions[i * 3] || position.y !== positions[i * 3 + 1] || position.z !== positions[i * 3 + 2]) {\n        position.toArray(positions, i * 3);\n        parentRef.current.geometry.attributes.position.needsUpdate = true;\n        positionRef.matrixWorldNeedsUpdate = true;\n      }\n\n      if (!positionRef.color.equals(color.fromArray(colors, i * 3))) {\n        positionRef.color.toArray(colors, i * 3);\n        parentRef.current.geometry.attributes.color.needsUpdate = true;\n      }\n\n      if (positionRef.size !== sizes[i]) {\n        sizes.set([positionRef.size], i);\n        parentRef.current.geometry.attributes.size.needsUpdate = true;\n      }\n    }\n  });\n  const events = React.useMemo(() => {\n    const events = {};\n\n    for (i = 0; i < refs.length; i++) {\n      var _refs$i$current;\n\n      Object.assign(events, (_refs$i$current = refs[i].current) == null ? void 0 : _refs$i$current.__r3f.handlers);\n    }\n\n    return Object.keys(events).reduce((prev, key) => ({ ...prev,\n      [key]: event => {\n        var _refs$event$index, _r3f, _r3f$handlers;\n\n        const object = (_refs$event$index = refs[event.index]) == null ? void 0 : _refs$event$index.current;\n        return object == null ? void 0 : (_r3f = object.__r3f) == null ? void 0 : (_r3f$handlers = _r3f.handlers) == null ? void 0 : _r3f$handlers[key]({ ...event,\n          object\n        });\n      }\n    }), {});\n  }, [children, refs]);\n  const api = React.useMemo(() => ({\n    subscribe: ref => {\n      setRefs(refs => [...refs, ref]);\n      return () => setRefs(refs => refs.filter(item => item.current !== ref.current));\n    }\n  }), []);\n  return (\n    /*#__PURE__*/\n    React.createElement(\"points\", _extends({\n      matrixAutoUpdate: false,\n      ref: mergeRefs([ref, parentRef])\n    }, events, props),\n    /*#__PURE__*/\n    React.createElement(\"bufferGeometry\", null,\n    /*#__PURE__*/\n    React.createElement(\"bufferAttribute\", {\n      attachObject: ['attributes', 'position'],\n      count: positions.length / 3,\n      array: positions,\n      itemSize: 3,\n      usage: THREE.DynamicDrawUsage\n    }),\n    /*#__PURE__*/\n    React.createElement(\"bufferAttribute\", {\n      attachObject: ['attributes', 'color'],\n      count: colors.length / 3,\n      array: colors,\n      itemSize: 3,\n      usage: THREE.DynamicDrawUsage\n    }),\n    /*#__PURE__*/\n    React.createElement(\"bufferAttribute\", {\n      attachObject: ['attributes', 'size'],\n      count: sizes.length,\n      array: sizes,\n      itemSize: 1,\n      usage: THREE.DynamicDrawUsage\n    })),\n    /*#__PURE__*/\n    React.createElement(context.Provider, {\n      value: api\n    }, children))\n  );\n});\nconst Point =\n/*#__PURE__*/\nReact.forwardRef(({\n  children,\n  ...props\n}, ref) => {\n  React.useMemo(() => extend({\n    Position\n  }), []);\n  const group = React.useRef();\n\n  const _React$useContext = React.useContext(context),\n        subscribe = _React$useContext.subscribe;\n\n  React.useLayoutEffect(() => subscribe(group), []);\n  return (\n    /*#__PURE__*/\n    React.createElement(\"position\", _extends({\n      ref: mergeRefs([ref, group])\n    }, props), children)\n  );\n});\n/**\n * Buffer implementation, relies on complete buffers of the correct number, leaves it to the user to update them\n */\n\nconst PointsBuffer =\n/*#__PURE__*/\nReact.forwardRef(({\n  children,\n  positions,\n  colors,\n  sizes,\n  stride = 3,\n  ...props\n}, forwardedRef) => {\n  const pointsRef = React.useRef(null);\n  useFrame(() => {\n    const attr = pointsRef.current.geometry.attributes;\n    attr.position.needsUpdate = true;\n    if (colors) attr.color.needsUpdate = true;\n    if (sizes) attr.size.needsUpdate = true;\n  });\n  return (\n    /*#__PURE__*/\n    React.createElement(\"points\", _extends({\n      ref: mergeRefs([forwardedRef, pointsRef])\n    }, props),\n    /*#__PURE__*/\n    React.createElement(\"bufferGeometry\", null,\n    /*#__PURE__*/\n    React.createElement(\"bufferAttribute\", {\n      attachObject: ['attributes', 'position'],\n      count: positions.length / stride,\n      array: positions,\n      itemSize: stride,\n      usage: THREE.DynamicDrawUsage\n    }), colors &&\n    /*#__PURE__*/\n    React.createElement(\"bufferAttribute\", {\n      attachObject: ['attributes', 'color'],\n      count: colors.length / stride,\n      array: colors,\n      itemSize: 3,\n      usage: THREE.DynamicDrawUsage\n    }), sizes &&\n    /*#__PURE__*/\n    React.createElement(\"bufferAttribute\", {\n      attachObject: ['attributes', 'size'],\n      count: sizes.length / stride,\n      array: sizes,\n      itemSize: 1,\n      usage: THREE.DynamicDrawUsage\n    })), children)\n  );\n});\nconst Points =\n/*#__PURE__*/\nReact.forwardRef((props, forwardedRef) => {\n  if (props.positions instanceof Float32Array) {\n    return (\n      /*#__PURE__*/\n      React.createElement(PointsBuffer, _extends({}, props, {\n        ref: forwardedRef\n      }))\n    );\n  } else return (\n    /*#__PURE__*/\n    React.createElement(PointsInstances, _extends({}, props, {\n      ref: forwardedRef\n    }))\n  );\n});\nexport { Point, Points, PointsBuffer };","map":null,"metadata":{},"sourceType":"module"}