{"ast":null,"code":"const t = new Uint8Array([0]),\n      e = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];\nvar n, i, s, a, r, o, l, f;\n!function (t) {\n  t[t.NONE = 0] = \"NONE\", t[t.BASISLZ = 1] = \"BASISLZ\", t[t.ZSTD = 2] = \"ZSTD\", t[t.ZLIB = 3] = \"ZLIB\";\n}(n || (n = {})), function (t) {\n  t[t.BASICFORMAT = 0] = \"BASICFORMAT\";\n}(i || (i = {})), function (t) {\n  t[t.UNSPECIFIED = 0] = \"UNSPECIFIED\", t[t.ETC1S = 163] = \"ETC1S\", t[t.UASTC = 166] = \"UASTC\";\n}(s || (s = {})), function (t) {\n  t[t.UNSPECIFIED = 0] = \"UNSPECIFIED\", t[t.SRGB = 1] = \"SRGB\";\n}(a || (a = {})), function (t) {\n  t[t.UNSPECIFIED = 0] = \"UNSPECIFIED\", t[t.LINEAR = 1] = \"LINEAR\", t[t.SRGB = 2] = \"SRGB\", t[t.ITU = 3] = \"ITU\", t[t.NTSC = 4] = \"NTSC\", t[t.SLOG = 5] = \"SLOG\", t[t.SLOG2 = 6] = \"SLOG2\";\n}(r || (r = {})), function (t) {\n  t[t.ALPHA_STRAIGHT = 0] = \"ALPHA_STRAIGHT\", t[t.ALPHA_PREMULTIPLIED = 1] = \"ALPHA_PREMULTIPLIED\";\n}(o || (o = {})), function (t) {\n  t[t.RGB = 0] = \"RGB\", t[t.RRR = 3] = \"RRR\", t[t.GGG = 4] = \"GGG\", t[t.AAA = 15] = \"AAA\";\n}(l || (l = {})), function (t) {\n  t[t.RGB = 0] = \"RGB\", t[t.RGBA = 3] = \"RGBA\", t[t.RRR = 4] = \"RRR\", t[t.RRRG = 5] = \"RRRG\";\n}(f || (f = {}));\n\nclass U {\n  constructor() {\n    this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = n.NONE, this.levels = [], this.dataFormatDescriptor = [{\n      vendorId: 0,\n      descriptorType: i.BASICFORMAT,\n      versionNumber: 2,\n      descriptorBlockSize: 40,\n      colorModel: s.UNSPECIFIED,\n      colorPrimaries: a.SRGB,\n      transferFunction: a.SRGB,\n      flags: o.ALPHA_STRAIGHT,\n      texelBlockDimension: {\n        x: 4,\n        y: 4,\n        z: 1,\n        w: 1\n      },\n      bytesPlane: [],\n      samples: []\n    }], this.keyValue = {}, this.globalData = null;\n  }\n\n}\n\nclass c {\n  constructor(t, e, n, i) {\n    this._dataView = new DataView(t.buffer, t.byteOffset + e, n), this._littleEndian = i, this._offset = 0;\n  }\n\n  _nextUint8() {\n    const t = this._dataView.getUint8(this._offset);\n\n    return this._offset += 1, t;\n  }\n\n  _nextUint16() {\n    const t = this._dataView.getUint16(this._offset, this._littleEndian);\n\n    return this._offset += 2, t;\n  }\n\n  _nextUint32() {\n    const t = this._dataView.getUint32(this._offset, this._littleEndian);\n\n    return this._offset += 4, t;\n  }\n\n  _nextUint64() {\n    const t = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);\n\n    return this._offset += 8, t;\n  }\n\n  _skip(t) {\n    return this._offset += t, this;\n  }\n\n  _scan(t, e = 0) {\n    const n = this._offset;\n    let i = 0;\n\n    for (; this._dataView.getUint8(this._offset) !== e && i < t;) i++, this._offset++;\n\n    return i < t && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n, i);\n  }\n\n}\n\nfunction h(t) {\n  return \"undefined\" != typeof TextEncoder ? new TextEncoder().encode(t) : Buffer.from(t);\n}\n\nfunction _(t) {\n  return \"undefined\" != typeof TextDecoder ? new TextDecoder().decode(t) : Buffer.from(t).toString(\"utf8\");\n}\n\nfunction g(t) {\n  let e = 0;\n\n  for (const n of t) e += n.byteLength;\n\n  const n = new Uint8Array(e);\n  let i = 0;\n\n  for (const e of t) n.set(new Uint8Array(e), i), i += e.byteLength;\n\n  return n;\n}\n\nfunction p(t) {\n  const n = new Uint8Array(t.buffer, t.byteOffset, e.length);\n  if (n[0] !== e[0] || n[1] !== e[1] || n[2] !== e[2] || n[3] !== e[3] || n[4] !== e[4] || n[5] !== e[5] || n[6] !== e[6] || n[7] !== e[7] || n[8] !== e[8] || n[9] !== e[9] || n[10] !== e[10] || n[11] !== e[11]) throw new Error(\"Missing KTX 2.0 identifier.\");\n  const i = new U(),\n        s = 17 * Uint32Array.BYTES_PER_ELEMENT,\n        a = new c(t, e.length, s, !0);\n  i.vkFormat = a._nextUint32(), i.typeSize = a._nextUint32(), i.pixelWidth = a._nextUint32(), i.pixelHeight = a._nextUint32(), i.pixelDepth = a._nextUint32(), i.layerCount = a._nextUint32(), i.faceCount = a._nextUint32();\n\n  const r = a._nextUint32();\n\n  i.supercompressionScheme = a._nextUint32();\n\n  const o = a._nextUint32(),\n        l = a._nextUint32(),\n        f = a._nextUint32(),\n        h = a._nextUint32(),\n        g = a._nextUint64(),\n        p = a._nextUint64(),\n        x = new c(t, e.length + s, 3 * r * 8, !0);\n\n  for (let e = 0; e < r; e++) i.levels.push({\n    levelData: new Uint8Array(t.buffer, t.byteOffset + x._nextUint64(), x._nextUint64()),\n    uncompressedByteLength: x._nextUint64()\n  });\n\n  const u = new c(t, o, l, !0),\n        y = {\n    vendorId: u._skip(4)._nextUint16(),\n    descriptorType: u._nextUint16(),\n    versionNumber: u._nextUint16(),\n    descriptorBlockSize: u._nextUint16(),\n    colorModel: u._nextUint8(),\n    colorPrimaries: u._nextUint8(),\n    transferFunction: u._nextUint8(),\n    flags: u._nextUint8(),\n    texelBlockDimension: {\n      x: u._nextUint8() + 1,\n      y: u._nextUint8() + 1,\n      z: u._nextUint8() + 1,\n      w: u._nextUint8() + 1\n    },\n    bytesPlane: [u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8()],\n    samples: []\n  },\n        D = (y.descriptorBlockSize / 4 - 6) / 4;\n\n  for (let t = 0; t < D; t++) y.samples[t] = {\n    bitOffset: u._nextUint16(),\n    bitLength: u._nextUint8(),\n    channelID: u._nextUint8(),\n    samplePosition: [u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8()],\n    sampleLower: u._nextUint32(),\n    sampleUpper: u._nextUint32()\n  };\n\n  i.dataFormatDescriptor.length = 0, i.dataFormatDescriptor.push(y);\n  const b = new c(t, f, h, !0);\n\n  for (; b._offset < h;) {\n    const t = b._nextUint32(),\n          e = b._scan(t),\n          n = _(e),\n          s = b._scan(t - e.byteLength);\n\n    i.keyValue[n] = n.match(/^ktx/i) ? _(s) : s, b._offset % 4 && b._skip(4 - b._offset % 4);\n  }\n\n  if (p <= 0) return i;\n\n  const d = new c(t, g, p, !0),\n        B = d._nextUint16(),\n        w = d._nextUint16(),\n        A = d._nextUint32(),\n        S = d._nextUint32(),\n        m = d._nextUint32(),\n        L = d._nextUint32(),\n        I = [];\n\n  for (let t = 0; t < r; t++) I.push({\n    imageFlags: d._nextUint32(),\n    rgbSliceByteOffset: d._nextUint32(),\n    rgbSliceByteLength: d._nextUint32(),\n    alphaSliceByteOffset: d._nextUint32(),\n    alphaSliceByteLength: d._nextUint32()\n  });\n\n  const R = g + d._offset,\n        E = R + A,\n        T = E + S,\n        O = T + m,\n        P = new Uint8Array(t.buffer, t.byteOffset + R, A),\n        C = new Uint8Array(t.buffer, t.byteOffset + E, S),\n        F = new Uint8Array(t.buffer, t.byteOffset + T, m),\n        G = new Uint8Array(t.buffer, t.byteOffset + O, L);\n  return i.globalData = {\n    endpointCount: B,\n    selectorCount: w,\n    imageDescs: I,\n    endpointsData: P,\n    selectorsData: C,\n    tablesData: F,\n    extendedData: G\n  }, i;\n}\n\nfunction x() {\n  return (x = Object.assign || function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var n = arguments[e];\n\n      for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);\n    }\n\n    return t;\n  }).apply(this, arguments);\n}\n\nconst u = {\n  keepWriter: !1\n};\n\nfunction y(n, s = {}) {\n  s = x({}, u, s);\n  let a = new ArrayBuffer(0);\n\n  if (n.globalData) {\n    const t = new ArrayBuffer(20 + 5 * n.globalData.imageDescs.length * 4),\n          e = new DataView(t);\n    e.setUint16(0, n.globalData.endpointCount, !0), e.setUint16(2, n.globalData.selectorCount, !0), e.setUint32(4, n.globalData.endpointsData.byteLength, !0), e.setUint32(8, n.globalData.selectorsData.byteLength, !0), e.setUint32(12, n.globalData.tablesData.byteLength, !0), e.setUint32(16, n.globalData.extendedData.byteLength, !0);\n\n    for (let t = 0; t < n.globalData.imageDescs.length; t++) {\n      const i = n.globalData.imageDescs[t];\n      e.setUint32(20 + 5 * t * 4 + 0, i.imageFlags, !0), e.setUint32(20 + 5 * t * 4 + 4, i.rgbSliceByteOffset, !0), e.setUint32(20 + 5 * t * 4 + 8, i.rgbSliceByteLength, !0), e.setUint32(20 + 5 * t * 4 + 12, i.alphaSliceByteOffset, !0), e.setUint32(20 + 5 * t * 4 + 16, i.alphaSliceByteLength, !0);\n    }\n\n    a = g([t, n.globalData.endpointsData, n.globalData.selectorsData, n.globalData.tablesData, n.globalData.extendedData]);\n  }\n\n  const r = [];\n  let o = n.keyValue;\n  s.keepWriter || (o = x({}, n.keyValue, {\n    KTXwriter: \"KTX-Parse v0.2.2\"\n  }));\n\n  for (const e in o) {\n    const n = o[e],\n          i = h(e),\n          s = \"string\" == typeof n ? h(n) : n,\n          a = i.byteLength + 1 + s.byteLength + 1,\n          l = a % 4 ? 4 - a % 4 : 0;\n    r.push(g([new Uint32Array([a]), i, t, s, t, new Uint8Array(l).fill(0)]));\n  }\n\n  const l = g(r);\n  if (1 !== n.dataFormatDescriptor.length || n.dataFormatDescriptor[0].descriptorType !== i.BASICFORMAT) throw new Error(\"Only BASICFORMAT Data Format Descriptor output supported.\");\n  const f = n.dataFormatDescriptor[0],\n        U = new ArrayBuffer(28 + 16 * f.samples.length),\n        c = new DataView(U);\n  c.setUint32(0, U.byteLength, !0), c.setUint16(4, f.vendorId, !0), c.setUint16(6, f.descriptorType, !0), c.setUint16(8, f.versionNumber, !0), c.setUint16(10, f.descriptorBlockSize, !0), c.setUint8(12, f.colorModel), c.setUint8(13, f.colorPrimaries), c.setUint8(14, f.transferFunction), c.setUint8(15, f.flags), c.setUint8(16, f.texelBlockDimension.x - 1), c.setUint8(17, f.texelBlockDimension.y - 1), c.setUint8(18, f.texelBlockDimension.z - 1), c.setUint8(19, f.texelBlockDimension.w - 1);\n\n  for (let t = 0; t < 8; t++) c.setUint8(20 + t, f.bytesPlane[t]);\n\n  for (let t = 0; t < f.samples.length; t++) {\n    const e = f.samples[t],\n          n = 28 + 16 * t;\n    c.setUint16(n + 0, e.bitOffset, !0), c.setUint8(n + 2, e.bitLength), c.setUint8(n + 3, e.channelID), c.setUint8(n + 4, e.samplePosition[0]), c.setUint8(n + 5, e.samplePosition[1]), c.setUint8(n + 6, e.samplePosition[2]), c.setUint8(n + 7, e.samplePosition[3]), c.setUint32(n + 8, e.sampleLower, !0), c.setUint32(n + 12, e.sampleUpper, !0);\n  }\n\n  const _ = e.length + 68 + 3 * n.levels.length * 8,\n        p = _ + U.byteLength;\n\n  let y = p + l.byteLength;\n  y % 8 && (y += 8 - y % 8);\n  const D = [],\n        b = new DataView(new ArrayBuffer(3 * n.levels.length * 8));\n  let d = y + a.byteLength;\n\n  for (let t = 0; t < n.levels.length; t++) {\n    const e = n.levels[t];\n    D.push(e.levelData), b.setBigUint64(24 * t + 0, BigInt(d), !0), b.setBigUint64(24 * t + 8, BigInt(e.levelData.byteLength), !0), b.setBigUint64(24 * t + 16, BigInt(e.uncompressedByteLength), !0), d += e.levelData.byteLength;\n  }\n\n  const B = new ArrayBuffer(68),\n        w = new DataView(B);\n  return w.setUint32(0, n.vkFormat, !0), w.setUint32(4, n.typeSize, !0), w.setUint32(8, n.pixelWidth, !0), w.setUint32(12, n.pixelHeight, !0), w.setUint32(16, n.pixelDepth, !0), w.setUint32(20, n.layerCount, !0), w.setUint32(24, n.faceCount, !0), w.setUint32(28, n.levels.length, !0), w.setUint32(32, n.supercompressionScheme, !0), w.setUint32(36, _, !0), w.setUint32(40, U.byteLength, !0), w.setUint32(44, p, !0), w.setUint32(48, l.byteLength, !0), w.setBigUint64(52, BigInt(y), !0), w.setBigUint64(60, BigInt(a.byteLength), !0), new Uint8Array(g([new Uint8Array(e).buffer, B, b.buffer, U, l, new ArrayBuffer(y - (p + l.byteLength)), a, ...D]));\n}\n\nexport { l as KTX2ChannelETC1S, f as KTX2ChannelUASTC, U as KTX2Container, i as KTX2DescriptorType, o as KTX2Flags, s as KTX2Model, a as KTX2Primaries, n as KTX2SupercompressionScheme, r as KTX2Transfer, p as read, y as write };","map":null,"metadata":{},"sourceType":"module"}