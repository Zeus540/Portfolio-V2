{"ast":null,"code":"import _slicedToArray from \"/home/zeus/Personal/Portfolio-V2/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { Plane, Vector3, Matrix4, Vector4, PerspectiveCamera, LinearFilter, WebGLRenderTarget, DepthTexture, DepthFormat, UnsignedShortType } from 'three';\nimport { extend, useThree, useFrame } from '@react-three/fiber';\nimport mergeRefs from 'react-merge-refs';\nimport { BlurPass } from '../materials/BlurPass.js';\nimport { MeshReflectorMaterial as MeshReflectorMaterial$1 } from '../materials/MeshReflectorMaterial.js';\nextend({\n  MeshReflectorMaterialImpl: MeshReflectorMaterial$1\n});\nconst MeshReflectorMaterial =\n/*#__PURE__*/\nReact.forwardRef(({\n  mixBlur = 0,\n  mixStrength = 1,\n  resolution = 256,\n  blur = [0, 0],\n  minDepthThreshold = 0.9,\n  maxDepthThreshold = 1,\n  depthScale = 0,\n  depthToBlurRatioBias = 0.25,\n  mirror = 0,\n  distortion = 1,\n  mixContrast = 1,\n  distortionMap,\n  reflectorOffset = 0,\n  ...props\n}, ref) => {\n  const gl = useThree(({\n    gl\n  }) => gl);\n  const camera = useThree(({\n    camera\n  }) => camera);\n  const scene = useThree(({\n    scene\n  }) => scene);\n  blur = Array.isArray(blur) ? blur : [blur, blur];\n  const hasBlur = blur[0] + blur[1] > 0;\n  const materialRef = React.useRef(null);\n\n  const _React$useState = React.useState(() => new Plane()),\n        _React$useState2 = _slicedToArray(_React$useState, 1),\n        reflectorPlane = _React$useState2[0];\n\n  const _React$useState3 = React.useState(() => new Vector3()),\n        _React$useState4 = _slicedToArray(_React$useState3, 1),\n        normal = _React$useState4[0];\n\n  const _React$useState5 = React.useState(() => new Vector3()),\n        _React$useState6 = _slicedToArray(_React$useState5, 1),\n        reflectorWorldPosition = _React$useState6[0];\n\n  const _React$useState7 = React.useState(() => new Vector3()),\n        _React$useState8 = _slicedToArray(_React$useState7, 1),\n        cameraWorldPosition = _React$useState8[0];\n\n  const _React$useState9 = React.useState(() => new Matrix4()),\n        _React$useState10 = _slicedToArray(_React$useState9, 1),\n        rotationMatrix = _React$useState10[0];\n\n  const _React$useState11 = React.useState(() => new Vector3(0, 0, -1)),\n        _React$useState12 = _slicedToArray(_React$useState11, 1),\n        lookAtPosition = _React$useState12[0];\n\n  const _React$useState13 = React.useState(() => new Vector4()),\n        _React$useState14 = _slicedToArray(_React$useState13, 1),\n        clipPlane = _React$useState14[0];\n\n  const _React$useState15 = React.useState(() => new Vector3()),\n        _React$useState16 = _slicedToArray(_React$useState15, 1),\n        view = _React$useState16[0];\n\n  const _React$useState17 = React.useState(() => new Vector3()),\n        _React$useState18 = _slicedToArray(_React$useState17, 1),\n        target = _React$useState18[0];\n\n  const _React$useState19 = React.useState(() => new Vector4()),\n        _React$useState20 = _slicedToArray(_React$useState19, 1),\n        q = _React$useState20[0];\n\n  const _React$useState21 = React.useState(() => new Matrix4()),\n        _React$useState22 = _slicedToArray(_React$useState21, 1),\n        textureMatrix = _React$useState22[0];\n\n  const _React$useState23 = React.useState(() => new PerspectiveCamera()),\n        _React$useState24 = _slicedToArray(_React$useState23, 1),\n        virtualCamera = _React$useState24[0];\n\n  const beforeRender = React.useCallback(() => {\n    var _materialRef$current; // TODO: As of R3f 7-8 this should be __r3f.parent\n\n\n    const parent = materialRef.current.parent || ((_materialRef$current = materialRef.current) == null ? void 0 : _materialRef$current.__r3f.parent);\n    if (!parent) return;\n    reflectorWorldPosition.setFromMatrixPosition(parent.matrixWorld);\n    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    rotationMatrix.extractRotation(parent.matrixWorld);\n    normal.set(0, 0, 1);\n    normal.applyMatrix4(rotationMatrix);\n    reflectorWorldPosition.addScaledVector(normal, reflectorOffset);\n    view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n    if (view.dot(normal) > 0) return;\n    view.reflect(normal).negate();\n    view.add(reflectorWorldPosition);\n    rotationMatrix.extractRotation(camera.matrixWorld);\n    lookAtPosition.set(0, 0, -1);\n    lookAtPosition.applyMatrix4(rotationMatrix);\n    lookAtPosition.add(cameraWorldPosition);\n    target.subVectors(reflectorWorldPosition, lookAtPosition);\n    target.reflect(normal).negate();\n    target.add(reflectorWorldPosition);\n    virtualCamera.position.copy(view);\n    virtualCamera.up.set(0, 1, 0);\n    virtualCamera.up.applyMatrix4(rotationMatrix);\n    virtualCamera.up.reflect(normal);\n    virtualCamera.lookAt(target);\n    virtualCamera.far = camera.far; // Used in WebGLBackground\n\n    virtualCamera.updateMatrixWorld();\n    virtualCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(virtualCamera.projectionMatrix);\n    textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n    textureMatrix.multiply(parent.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n    reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n    reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n    clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n    const projectionMatrix = virtualCamera.projectionMatrix;\n    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    q.z = -1.0;\n    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = clipPlane.z + 1.0;\n    projectionMatrix.elements[14] = clipPlane.w;\n  }, [camera, reflectorOffset]);\n\n  const _React$useMemo = React.useMemo(() => {\n    const parameters = {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      encoding: gl.outputEncoding\n    };\n    const fbo1 = new WebGLRenderTarget(resolution, resolution, parameters);\n    fbo1.depthBuffer = true;\n    fbo1.depthTexture = new DepthTexture(resolution, resolution);\n    fbo1.depthTexture.format = DepthFormat;\n    fbo1.depthTexture.type = UnsignedShortType;\n    const fbo2 = new WebGLRenderTarget(resolution, resolution, parameters);\n    const blurpass = new BlurPass({\n      gl,\n      resolution,\n      width: blur[0],\n      height: blur[1],\n      minDepthThreshold,\n      maxDepthThreshold,\n      depthScale,\n      depthToBlurRatioBias\n    });\n    const reflectorProps = {\n      mirror,\n      textureMatrix,\n      mixBlur,\n      tDiffuse: fbo1.texture,\n      tDepth: fbo1.depthTexture,\n      tDiffuseBlur: fbo2.texture,\n      hasBlur,\n      mixStrength,\n      minDepthThreshold,\n      maxDepthThreshold,\n      depthScale,\n      depthToBlurRatioBias,\n      transparent: true,\n      distortion,\n      distortionMap,\n      mixContrast,\n      'defines-USE_BLUR': hasBlur ? '' : undefined,\n      'defines-USE_DEPTH': depthScale > 0 ? '' : undefined,\n      'defines-USE_DISTORTION': distortionMap ? '' : undefined\n    };\n    return [fbo1, fbo2, blurpass, reflectorProps];\n  }, [gl, blur, textureMatrix, resolution, mirror, hasBlur, mixBlur, mixStrength, minDepthThreshold, maxDepthThreshold, depthScale, depthToBlurRatioBias, distortion, distortionMap, mixContrast]),\n        _React$useMemo2 = _slicedToArray(_React$useMemo, 4),\n        fbo1 = _React$useMemo2[0],\n        fbo2 = _React$useMemo2[1],\n        blurpass = _React$useMemo2[2],\n        reflectorProps = _React$useMemo2[3];\n\n  useFrame(() => {\n    var _materialRef$current2; // TODO: As of R3f 7-8 this should be __r3f.parent\n\n\n    const parent = materialRef.current.parent || ((_materialRef$current2 = materialRef.current) == null ? void 0 : _materialRef$current2.__r3f.parent);\n    if (!parent) return;\n    parent.visible = false;\n    const currentXrEnabled = gl.xr.enabled;\n    const currentShadowAutoUpdate = gl.shadowMap.autoUpdate;\n    beforeRender();\n    gl.xr.enabled = false;\n    gl.shadowMap.autoUpdate = false;\n    gl.setRenderTarget(fbo1);\n    gl.state.buffers.depth.setMask(true);\n    if (!gl.autoClear) gl.clear();\n    gl.render(scene, virtualCamera);\n    if (hasBlur) blurpass.render(gl, fbo1, fbo2);\n    gl.xr.enabled = currentXrEnabled;\n    gl.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    parent.visible = true;\n    gl.setRenderTarget(null);\n  });\n  return (\n    /*#__PURE__*/\n    React.createElement(\"meshReflectorMaterialImpl\", _extends({\n      attach: \"material\" // Defines can't be updated dynamically, so we need to recreate the material\n      ,\n      key: 'key' + reflectorProps['defines-USE_BLUR'] + reflectorProps['defines-USE_DEPTH'] + reflectorProps['defines-USE_DISTORTION'],\n      ref: mergeRefs([materialRef, ref])\n    }, reflectorProps, props))\n  );\n});\nexport { MeshReflectorMaterial };","map":null,"metadata":{},"sourceType":"module"}