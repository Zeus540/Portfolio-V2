{"ast":null,"code":"import { CubeUVRefractionMapping, CubeUVReflectionMapping, CubeRefractionMapping, CubeReflectionMapping, LinearEncoding, sRGBEncoding } from 'three';\nimport { NodeUniform } from './NodeUniform.js';\nimport { NodeUtils } from './NodeUtils.js';\nimport { NodeLib } from './NodeLib.js';\nimport { FunctionNode } from './FunctionNode.js';\nimport { ConstNode } from './ConstNode.js';\nimport { StructNode } from './StructNode.js';\nimport { Vector2Node } from '../inputs/Vector2Node.js';\nimport { Vector3Node } from '../inputs/Vector3Node.js';\nimport { Vector4Node } from '../inputs/Vector4Node.js';\nimport { TextureNode } from '../inputs/TextureNode.js';\nimport { CubeTextureNode } from '../inputs/CubeTextureNode.js';\nimport { TextureCubeNode } from '../misc/TextureCubeNode.js';\nvar elements = NodeUtils.elements,\n    constructors = ['float', 'vec2', 'vec3', 'vec4'],\n    convertFormatToType = {\n  float: 'f',\n  vec2: 'v2',\n  vec3: 'v3',\n  vec4: 'v4',\n  mat4: 'v4',\n  int: 'i',\n  bool: 'b'\n},\n    convertTypeToFormat = {\n  t: 'sampler2D',\n  tc: 'samplerCube',\n  b: 'bool',\n  i: 'int',\n  f: 'float',\n  c: 'vec3',\n  v2: 'vec2',\n  v3: 'vec3',\n  v4: 'vec4',\n  m3: 'mat3',\n  m4: 'mat4'\n};\n\nfunction NodeBuilder() {\n  this.slots = [];\n  this.caches = [];\n  this.contexts = [];\n  this.keywords = {};\n  this.nodeData = {};\n  this.requires = {\n    uv: [],\n    color: [],\n    lights: false,\n    fog: false,\n    transparent: false,\n    irradiance: false\n  };\n  this.includes = {\n    consts: [],\n    functions: [],\n    structs: []\n  };\n  this.attributes = {};\n  this.prefixCode = ['#ifdef TEXTURE_LOD_EXT', '\t#define texCube(a, b) textureCube(a, b)', '\t#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)', '\t#define tex2D(a, b) texture2D(a, b)', '\t#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)', '#else', '\t#define texCube(a, b) textureCube(a, b)', '\t#define texCubeBias(a, b, c) textureCube(a, b, c)', '\t#define tex2D(a, b) texture2D(a, b)', '\t#define tex2DBias(a, b, c) texture2D(a, b, c)', '#endif', '#include <packing>', '#include <common>'].join('\\n');\n  this.parsCode = {\n    vertex: '',\n    fragment: ''\n  };\n  this.code = {\n    vertex: '',\n    fragment: ''\n  };\n  this.nodeCode = {\n    vertex: '',\n    fragment: ''\n  };\n  this.resultCode = {\n    vertex: '',\n    fragment: ''\n  };\n  this.finalCode = {\n    vertex: '',\n    fragment: ''\n  };\n  this.inputs = {\n    uniforms: {\n      list: [],\n      vertex: [],\n      fragment: []\n    },\n    vars: {\n      varying: [],\n      vertex: [],\n      fragment: []\n    }\n  }; // send to material\n\n  this.defines = {};\n  this.uniforms = {};\n  this.extensions = {};\n  this.updaters = [];\n  this.nodes = []; // --\n\n  this.analyzing = false;\n}\n\nNodeBuilder.prototype = {\n  constructor: NodeBuilder,\n  build: function (vertex, fragment) {\n    this.buildShader('vertex', vertex);\n    this.buildShader('fragment', fragment);\n\n    for (let i = 0; i < this.requires.uv.length; i++) {\n      if (this.requires.uv[i]) {\n        var uvIndex = i > 0 ? i + 1 : '';\n        this.addVaryCode('varying vec2 vUv' + uvIndex + ';');\n\n        if (i > 0) {\n          this.addVertexParsCode('attribute vec2 uv' + uvIndex + ';');\n        }\n\n        this.addVertexFinalCode('vUv' + uvIndex + ' = uv' + uvIndex + ';');\n      }\n    }\n\n    if (this.requires.color[0]) {\n      this.addVaryCode('varying vec4 vColor;');\n      this.addVertexParsCode('attribute vec4 color;');\n      this.addVertexFinalCode('vColor = color;');\n    }\n\n    if (this.requires.color[1]) {\n      this.addVaryCode('varying vec4 vColor2;');\n      this.addVertexParsCode('attribute vec4 color2;');\n      this.addVertexFinalCode('vColor2 = color2;');\n    }\n\n    if (this.requires.position) {\n      this.addVaryCode('varying vec3 vPosition;');\n      this.addVertexFinalCode('vPosition = transformed;');\n    }\n\n    if (this.requires.worldPosition) {\n      this.addVaryCode('varying vec3 vWPosition;');\n      this.addVertexFinalCode('vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;');\n    }\n\n    if (this.requires.normal) {\n      this.addVaryCode('varying vec3 vObjectNormal;');\n      this.addVertexFinalCode('vObjectNormal = normal;');\n    }\n\n    if (this.requires.worldNormal) {\n      this.addVaryCode('varying vec3 vWNormal;');\n      this.addVertexFinalCode('vWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;');\n    }\n\n    return this;\n  },\n  buildShader: function (shader, node) {\n    this.resultCode[shader] = node.build(this.setShader(shader), 'v4');\n  },\n  setMaterial: function (material, renderer) {\n    this.material = material;\n    this.renderer = renderer;\n    this.requires.lights = material.lights;\n    this.requires.fog = material.fog;\n    this.mergeDefines(material.defines);\n    return this;\n  },\n  addFlow: function (slot, cache, context) {\n    return this.addSlot(slot).addCache(cache).addContext(context);\n  },\n  removeFlow: function () {\n    return this.removeSlot().removeCache().removeContext();\n  },\n  addCache: function (name) {\n    this.cache = name || '';\n    this.caches.push(this.cache);\n    return this;\n  },\n  removeCache: function () {\n    this.caches.pop();\n    this.cache = this.caches[this.caches.length - 1] || '';\n    return this;\n  },\n  addContext: function (context) {\n    this.context = Object.assign({}, this.context, context);\n    this.context.extra = this.context.extra || {};\n    this.contexts.push(this.context);\n    return this;\n  },\n  removeContext: function () {\n    this.contexts.pop();\n    this.context = this.contexts[this.contexts.length - 1] || {};\n    return this;\n  },\n  addSlot: function (name) {\n    this.slot = name || '';\n    this.slots.push(this.slot);\n    return this;\n  },\n  removeSlot: function () {\n    this.slots.pop();\n    this.slot = this.slots[this.slots.length - 1] || '';\n    return this;\n  },\n  addVertexCode: function (code) {\n    this.addCode(code, 'vertex');\n  },\n  addFragmentCode: function (code) {\n    this.addCode(code, 'fragment');\n  },\n  addCode: function (code, shader) {\n    this.code[shader || this.shader] += code + '\\n';\n  },\n  addVertexNodeCode: function (code) {\n    this.addNodeCode(code, 'vertex');\n  },\n  addFragmentNodeCode: function (code) {\n    this.addNodeCode(code, 'fragment');\n  },\n  addNodeCode: function (code, shader) {\n    this.nodeCode[shader || this.shader] += code + '\\n';\n  },\n  clearNodeCode: function (shader) {\n    shader = shader || this.shader;\n    var code = this.nodeCode[shader];\n    this.nodeCode[shader] = '';\n    return code;\n  },\n  clearVertexNodeCode: function () {\n    return this.clearNodeCode('vertex');\n  },\n  clearFragmentNodeCode: function () {\n    return this.clearNodeCode('fragment');\n  },\n  addVertexFinalCode: function (code) {\n    this.addFinalCode(code, 'vertex');\n  },\n  addFragmentFinalCode: function (code) {\n    this.addFinalCode(code, 'fragment');\n  },\n  addFinalCode: function (code, shader) {\n    this.finalCode[shader || this.shader] += code + '\\n';\n  },\n  addVertexParsCode: function (code) {\n    this.addParsCode(code, 'vertex');\n  },\n  addFragmentParsCode: function (code) {\n    this.addParsCode(code, 'fragment');\n  },\n  addParsCode: function (code, shader) {\n    this.parsCode[shader || this.shader] += code + '\\n';\n  },\n  addVaryCode: function (code) {\n    this.addVertexParsCode(code);\n    this.addFragmentParsCode(code);\n  },\n  isCache: function (name) {\n    return this.caches.indexOf(name) !== -1;\n  },\n  isSlot: function (name) {\n    return this.slots.indexOf(name) !== -1;\n  },\n  define: function (name, value) {\n    this.defines[name] = value === undefined ? 1 : value;\n  },\n  require: function (name) {\n    this.requires[name] = true;\n  },\n  isDefined: function (name) {\n    return this.defines[name] !== undefined;\n  },\n  getVar: function (uuid, type, ns, shader = 'varying', prefix = 'V', label = '') {\n    var vars = this.getVars(shader),\n        data = vars[uuid];\n\n    if (!data) {\n      var index = vars.length,\n          name = ns ? ns : 'node' + prefix + index + (label ? '_' + label : '');\n      data = {\n        name: name,\n        type: type\n      };\n      vars.push(data);\n      vars[uuid] = data;\n    }\n\n    return data;\n  },\n  getTempVar: function (uuid, type, ns, label) {\n    return this.getVar(uuid, type, ns, this.shader, 'T', label);\n  },\n  getAttribute: function (name, type) {\n    if (!this.attributes[name]) {\n      var varying = this.getVar(name, type);\n      this.addVertexParsCode('attribute ' + type + ' ' + name + ';');\n      this.addVertexFinalCode(varying.name + ' = ' + name + ';');\n      this.attributes[name] = {\n        varying: varying,\n        name: name,\n        type: type\n      };\n    }\n\n    return this.attributes[name];\n  },\n  getCode: function (shader) {\n    return [this.prefixCode, this.parsCode[shader], this.getVarListCode(this.getVars('varying'), 'varying'), this.getVarListCode(this.inputs.uniforms[shader], 'uniform'), this.getIncludesCode('consts', shader), this.getIncludesCode('structs', shader), this.getIncludesCode('functions', shader), 'void main() {', this.getVarListCode(this.getVars(shader)), this.code[shader], this.resultCode[shader], this.finalCode[shader], '}'].join('\\n');\n  },\n  getVarListCode: function (vars, prefix) {\n    prefix = prefix || '';\n    var code = '';\n\n    for (let i = 0, l = vars.length; i < l; ++i) {\n      var nVar = vars[i],\n          type = nVar.type,\n          name = nVar.name;\n      var formatType = this.getFormatByType(type);\n\n      if (formatType === undefined) {\n        throw new Error('Node pars ' + formatType + ' not found.');\n      }\n\n      code += prefix + ' ' + formatType + ' ' + name + ';\\n';\n    }\n\n    return code;\n  },\n  getVars: function (shader) {\n    return this.inputs.vars[shader || this.shader];\n  },\n  getNodeData: function (node) {\n    var uuid = node.isNode ? node.uuid : node;\n    return this.nodeData[uuid] = this.nodeData[uuid] || {};\n  },\n  createUniform: function (shader, type, node, ns, needsUpdate, label) {\n    var uniforms = this.inputs.uniforms,\n        index = uniforms.list.length;\n    var uniform = new NodeUniform({\n      type: type,\n      name: ns ? ns : 'nodeU' + index + (label ? '_' + label : ''),\n      node: node,\n      needsUpdate: needsUpdate\n    });\n    uniforms.list.push(uniform);\n    uniforms[shader].push(uniform);\n    uniforms[shader][uniform.name] = uniform;\n    this.uniforms[uniform.name] = uniform;\n    return uniform;\n  },\n  createVertexUniform: function (type, node, ns, needsUpdate, label) {\n    return this.createUniform('vertex', type, node, ns, needsUpdate, label);\n  },\n  createFragmentUniform: function (type, node, ns, needsUpdate, label) {\n    return this.createUniform('fragment', type, node, ns, needsUpdate, label);\n  },\n  include: function (node, parent, source) {\n    var includesStruct;\n    node = typeof node === 'string' ? NodeLib.get(node) : node;\n\n    if (this.context.include === false) {\n      return node.name;\n    }\n\n    if (node instanceof FunctionNode) {\n      includesStruct = this.includes.functions;\n    } else if (node instanceof ConstNode) {\n      includesStruct = this.includes.consts;\n    } else if (node instanceof StructNode) {\n      includesStruct = this.includes.structs;\n    }\n\n    var includes = includesStruct[this.shader] = includesStruct[this.shader] || [];\n\n    if (node) {\n      var included = includes[node.name];\n\n      if (!included) {\n        included = includes[node.name] = {\n          node: node,\n          deps: []\n        };\n        includes.push(included);\n        included.src = node.build(this, 'source');\n      }\n\n      if (node instanceof FunctionNode && parent && includes[parent.name] && includes[parent.name].deps.indexOf(node) == -1) {\n        includes[parent.name].deps.push(node);\n\n        if (node.includes && node.includes.length) {\n          var i = 0;\n\n          do {\n            this.include(node.includes[i++], parent);\n          } while (i < node.includes.length);\n        }\n      }\n\n      if (source) {\n        included.src = source;\n      }\n\n      return node.name;\n    } else {\n      throw new Error('Include not found.');\n    }\n  },\n  colorToVectorProperties: function (color) {\n    return color.replace('r', 'x').replace('g', 'y').replace('b', 'z').replace('a', 'w');\n  },\n  colorToVector: function (color) {\n    return color.replace(/c/g, 'v3');\n  },\n  getIncludes: function (type, shader) {\n    return this.includes[type][shader || this.shader];\n  },\n  getIncludesCode: function () {\n    function sortByPosition(a, b) {\n      return a.deps.length - b.deps.length;\n    }\n\n    return function getIncludesCode(type, shader) {\n      var includes = this.getIncludes(type, shader);\n      if (!includes) return '';\n      var code = '',\n          includes = includes.sort(sortByPosition);\n\n      for (let i = 0; i < includes.length; i++) {\n        if (includes[i].src) code += includes[i].src + '\\n';\n      }\n\n      return code;\n    };\n  }(),\n  getConstructorFromLength: function (len) {\n    return constructors[len - 1];\n  },\n  isTypeMatrix: function (format) {\n    return /^m/.test(format);\n  },\n  getTypeLength: function (type) {\n    if (type === 'f') return 1;\n    return parseInt(this.colorToVector(type).substr(1));\n  },\n  getTypeFromLength: function (len) {\n    if (len === 1) return 'f';\n    return 'v' + len;\n  },\n  findNode: function () {\n    for (let i = 0; i < arguments.length; i++) {\n      var nodeCandidate = arguments[i];\n\n      if (nodeCandidate !== undefined && nodeCandidate.isNode) {\n        return nodeCandidate;\n      }\n    }\n  },\n  resolve: function () {\n    for (let i = 0; i < arguments.length; i++) {\n      var nodeCandidate = arguments[i];\n\n      if (nodeCandidate !== undefined) {\n        if (nodeCandidate.isNode) {\n          return nodeCandidate;\n        } else if (nodeCandidate.isTexture) {\n          switch (nodeCandidate.mapping) {\n            case CubeReflectionMapping:\n            case CubeRefractionMapping:\n              return new CubeTextureNode(nodeCandidate);\n\n            case CubeUVReflectionMapping:\n            case CubeUVRefractionMapping:\n              return new TextureCubeNode(new TextureNode(nodeCandidate));\n\n            default:\n              return new TextureNode(nodeCandidate);\n          }\n        } else if (nodeCandidate.isVector2) {\n          return new Vector2Node(nodeCandidate);\n        } else if (nodeCandidate.isVector3) {\n          return new Vector3Node(nodeCandidate);\n        } else if (nodeCandidate.isVector4) {\n          return new Vector4Node(nodeCandidate);\n        }\n      }\n    }\n  },\n  format: function (code, from, to) {\n    var typeToType = this.colorToVector(to + ' <- ' + from);\n\n    switch (typeToType) {\n      case 'f <- v2':\n        return code + '.x';\n\n      case 'f <- v3':\n        return code + '.x';\n\n      case 'f <- v4':\n        return code + '.x';\n\n      case 'f <- i':\n      case 'f <- b':\n        return 'float( ' + code + ' )';\n\n      case 'v2 <- f':\n        return 'vec2( ' + code + ' )';\n\n      case 'v2 <- v3':\n        return code + '.xy';\n\n      case 'v2 <- v4':\n        return code + '.xy';\n\n      case 'v2 <- i':\n      case 'v2 <- b':\n        return 'vec2( float( ' + code + ' ) )';\n\n      case 'v3 <- f':\n        return 'vec3( ' + code + ' )';\n\n      case 'v3 <- v2':\n        return 'vec3( ' + code + ', 0.0 )';\n\n      case 'v3 <- v4':\n        return code + '.xyz';\n\n      case 'v3 <- i':\n      case 'v3 <- b':\n        return 'vec2( float( ' + code + ' ) )';\n\n      case 'v4 <- f':\n        return 'vec4( ' + code + ' )';\n\n      case 'v4 <- v2':\n        return 'vec4( ' + code + ', 0.0, 1.0 )';\n\n      case 'v4 <- v3':\n        return 'vec4( ' + code + ', 1.0 )';\n\n      case 'v4 <- i':\n      case 'v4 <- b':\n        return 'vec4( float( ' + code + ' ) )';\n\n      case 'i <- f':\n      case 'i <- b':\n        return 'int( ' + code + ' )';\n\n      case 'i <- v2':\n        return 'int( ' + code + '.x )';\n\n      case 'i <- v3':\n        return 'int( ' + code + '.x )';\n\n      case 'i <- v4':\n        return 'int( ' + code + '.x )';\n\n      case 'b <- f':\n        return '( ' + code + ' != 0.0 )';\n\n      case 'b <- v2':\n        return '( ' + code + ' != vec2( 0.0 ) )';\n\n      case 'b <- v3':\n        return '( ' + code + ' != vec3( 0.0 ) )';\n\n      case 'b <- v4':\n        return '( ' + code + ' != vec4( 0.0 ) )';\n\n      case 'b <- i':\n        return '( ' + code + ' != 0 )';\n    }\n\n    return code;\n  },\n  getTypeByFormat: function (format) {\n    return convertFormatToType[format] || format;\n  },\n  getFormatByType: function (type) {\n    return convertTypeToFormat[type] || type;\n  },\n  getUuid: function (uuid, useCache) {\n    useCache = useCache !== undefined ? useCache : true;\n    if (useCache && this.cache) uuid = this.cache + '-' + uuid;\n    return uuid;\n  },\n  getElementByIndex: function (index) {\n    return elements[index];\n  },\n  getIndexByElement: function (elm) {\n    return elements.indexOf(elm);\n  },\n  isShader: function (shader) {\n    return this.shader === shader;\n  },\n  setShader: function (shader) {\n    this.shader = shader;\n    return this;\n  },\n  mergeDefines: function (defines) {\n    for (let name in defines) {\n      this.defines[name] = defines[name];\n    }\n\n    return this.defines;\n  },\n  mergeUniform: function (uniforms) {\n    for (let name in uniforms) {\n      this.uniforms[name] = uniforms[name];\n    }\n\n    return this.uniforms;\n  },\n  getTextureEncodingFromMap: function (map) {\n    var encoding;\n\n    if (!map) {\n      encoding = LinearEncoding;\n    } else if (map.isTexture) {\n      encoding = map.encoding;\n    } else if (map.isWebGLRenderTarget) {\n      console.warn(\"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\");\n      encoding = map.texture.encoding;\n    }\n\n    if (encoding === LinearEncoding && this.context.gamma) {\n      encoding = sRGBEncoding;\n    }\n\n    return encoding;\n  }\n};\nexport { NodeBuilder };","map":null,"metadata":{},"sourceType":"module"}