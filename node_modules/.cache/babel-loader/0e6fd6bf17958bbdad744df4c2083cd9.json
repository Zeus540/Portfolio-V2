{"ast":null,"code":"import { Quaternion, Vector3, Object3D, SphereGeometry, MeshBasicMaterial, Color, LineBasicMaterial, Matrix4, Mesh, Line, BufferGeometry, BufferAttribute } from 'three';\n/**\n * CCD Algorithm\n *  - https://sites.google.com/site/auraliusproject/ccd-algorithm\n *\n * // ik parameter example\n * //\n * // target, effector, index in links are bone index in skeleton.bones.\n * // the bones relation should be\n * // <-- parent                                  child -->\n * // links[ n ], links[ n - 1 ], ..., links[ 0 ], effector\n * iks = [ {\n *\ttarget: 1,\n *\teffector: 2,\n *\tlinks: [ { index: 5, limitation: new Vector3( 1, 0, 0 ) }, { index: 4, enabled: false }, { index : 3 } ],\n *\titeration: 10,\n *\tminAngle: 0.0,\n *\tmaxAngle: 1.0,\n * } ];\n */\n\nconst CCDIKSolver = (() => {\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Array<Object>} iks\n   */\n  function CCDIKSolver(mesh, iks) {\n    this.mesh = mesh;\n    this.iks = iks || [];\n\n    this._valid();\n  }\n\n  CCDIKSolver.prototype = {\n    constructor: CCDIKSolver,\n\n    /**\n     * Update IK bones.\n     *\n     * @return {CCDIKSolver}\n     */\n    update: (() => {\n      const q = new Quaternion();\n      const targetPos = new Vector3();\n      const targetVec = new Vector3();\n      const effectorPos = new Vector3();\n      const effectorVec = new Vector3();\n      const linkPos = new Vector3();\n      const invLinkQ = new Quaternion();\n      const linkScale = new Vector3();\n      const axis = new Vector3();\n      const vector = new Vector3();\n      return function update() {\n        const bones = this.mesh.skeleton.bones;\n        const iks = this.iks; // for reference overhead reduction in loop\n\n        const math = Math;\n\n        for (let i = 0, il = iks.length; i < il; i++) {\n          const ik = iks[i];\n          const effector = bones[ik.effector];\n          const target = bones[ik.target]; // don't use getWorldPosition() here for the performance\n          // because it calls updateMatrixWorld( true ) inside.\n\n          targetPos.setFromMatrixPosition(target.matrixWorld);\n          const links = ik.links;\n          const iteration = ik.iteration !== undefined ? ik.iteration : 1;\n\n          for (let j = 0; j < iteration; j++) {\n            let rotated = false;\n\n            for (let k = 0, kl = links.length; k < kl; k++) {\n              const link = bones[links[k].index]; // skip this link and following links.\n              // this skip is used for MMD performance optimization.\n\n              if (links[k].enabled === false) break;\n              const limitation = links[k].limitation;\n              const rotationMin = links[k].rotationMin;\n              const rotationMax = links[k].rotationMax; // don't use getWorldPosition/Quaternion() here for the performance\n              // because they call updateMatrixWorld( true ) inside.\n\n              link.matrixWorld.decompose(linkPos, invLinkQ, linkScale);\n              invLinkQ.invert();\n              effectorPos.setFromMatrixPosition(effector.matrixWorld); // work in link world\n\n              effectorVec.subVectors(effectorPos, linkPos);\n              effectorVec.applyQuaternion(invLinkQ);\n              effectorVec.normalize();\n              targetVec.subVectors(targetPos, linkPos);\n              targetVec.applyQuaternion(invLinkQ);\n              targetVec.normalize();\n              let angle = targetVec.dot(effectorVec);\n\n              if (angle > 1.0) {\n                angle = 1.0;\n              } else if (angle < -1.0) {\n                angle = -1.0;\n              }\n\n              angle = math.acos(angle); // skip if changing angle is too small to prevent vibration of bone\n              // Refer to http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js\n\n              if (angle < 1e-5) continue;\n\n              if (ik.minAngle !== undefined && angle < ik.minAngle) {\n                angle = ik.minAngle;\n              }\n\n              if (ik.maxAngle !== undefined && angle > ik.maxAngle) {\n                angle = ik.maxAngle;\n              }\n\n              axis.crossVectors(effectorVec, targetVec);\n              axis.normalize();\n              q.setFromAxisAngle(axis, angle);\n              link.quaternion.multiply(q); // TODO: re-consider the limitation specification\n\n              if (limitation !== undefined) {\n                let c = link.quaternion.w;\n                if (c > 1.0) c = 1.0;\n                const c2 = math.sqrt(1 - c * c);\n                link.quaternion.set(limitation.x * c2, limitation.y * c2, limitation.z * c2, c);\n              }\n\n              if (rotationMin !== undefined) {\n                link.rotation.setFromVector3(link.rotation.toVector3(vector).max(rotationMin));\n              }\n\n              if (rotationMax !== undefined) {\n                link.rotation.setFromVector3(link.rotation.toVector3(vector).min(rotationMax));\n              }\n\n              link.updateMatrixWorld(true);\n              rotated = true;\n            }\n\n            if (!rotated) break;\n          }\n        }\n\n        return this;\n      };\n    })(),\n\n    /**\n     * Creates Helper\n     *\n     * @return {CCDIKHelper}\n     */\n    createHelper: function () {\n      return new CCDIKHelper(this.mesh, this.mesh.geometry.userData.MMD.iks);\n    },\n    // private methods\n    _valid: function () {\n      const iks = this.iks;\n      const bones = this.mesh.skeleton.bones;\n\n      for (let i = 0, il = iks.length; i < il; i++) {\n        const ik = iks[i];\n        const effector = bones[ik.effector];\n        const links = ik.links;\n        let link0, link1;\n        link0 = effector;\n\n        for (let j = 0, jl = links.length; j < jl; j++) {\n          link1 = bones[links[j].index];\n\n          if (link0.parent !== link1) {\n            console.warn(`THREE.CCDIKSolver: bone ${link0.name} is not the child of bone ${link1.name}`);\n          }\n\n          link0 = link1;\n        }\n      }\n    }\n  };\n  /**\n   * Visualize IK bones\n   *\n   * @param {SkinnedMesh} mesh\n   * @param {Array<Object>} iks\n   */\n\n  function CCDIKHelper(mesh, iks) {\n    Object3D.call(this);\n    this.root = mesh;\n    this.iks = iks || [];\n    this.matrix.copy(mesh.matrixWorld);\n    this.matrixAutoUpdate = false;\n    this.sphereGeometry = new SphereGeometry(0.25, 16, 8);\n    this.targetSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0xff8888),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.effectorSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x88ff88),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.linkSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x8888ff),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.lineMaterial = new LineBasicMaterial({\n      color: new Color(0xff0000),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n\n    this._init();\n  }\n\n  CCDIKHelper.prototype = Object.assign(Object.create(Object3D.prototype), {\n    constructor: CCDIKHelper,\n\n    /**\n     * Updates IK bones visualization.\n     */\n    updateMatrixWorld: (() => {\n      const matrix = new Matrix4();\n      const vector = new Vector3();\n\n      function getPosition(bone, matrixWorldInv) {\n        return vector.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv);\n      }\n\n      function setPositionOfBoneToAttributeArray(array, index, bone, matrixWorldInv) {\n        const v = getPosition(bone, matrixWorldInv);\n        array[index * 3 + 0] = v.x;\n        array[index * 3 + 1] = v.y;\n        array[index * 3 + 2] = v.z;\n      }\n\n      return function updateMatrixWorld(force) {\n        const mesh = this.root;\n\n        if (this.visible) {\n          let offset = 0;\n          const iks = this.iks;\n          const bones = mesh.skeleton.bones;\n          matrix.copy(mesh.matrixWorld).invert();\n\n          for (let i = 0, il = iks.length; i < il; i++) {\n            const ik = iks[i];\n            const targetBone = bones[ik.target];\n            const effectorBone = bones[ik.effector];\n            const targetMesh = this.children[offset++];\n            const effectorMesh = this.children[offset++];\n            targetMesh.position.copy(getPosition(targetBone, matrix));\n            effectorMesh.position.copy(getPosition(effectorBone, matrix));\n\n            for (let j = 0, jl = ik.links.length; j < jl; j++) {\n              var link = ik.links[j];\n              var linkBone = bones[link.index];\n              const linkMesh = this.children[offset++];\n              linkMesh.position.copy(getPosition(linkBone, matrix));\n            }\n\n            const line = this.children[offset++];\n            const array = line.geometry.attributes.position.array;\n            setPositionOfBoneToAttributeArray(array, 0, targetBone, matrix);\n            setPositionOfBoneToAttributeArray(array, 1, effectorBone, matrix);\n\n            for (let j = 0, jl = ik.links.length; j < jl; j++) {\n              var link = ik.links[j];\n              var linkBone = bones[link.index];\n              setPositionOfBoneToAttributeArray(array, j + 2, linkBone, matrix);\n            }\n\n            line.geometry.attributes.position.needsUpdate = true;\n          }\n        }\n\n        this.matrix.copy(mesh.matrixWorld);\n        Object3D.prototype.updateMatrixWorld.call(this, force);\n      };\n    })(),\n    // private method\n    _init: function () {\n      const scope = this;\n      const iks = this.iks;\n\n      function createLineGeometry(ik) {\n        const geometry = new BufferGeometry();\n        const vertices = new Float32Array((2 + ik.links.length) * 3);\n        geometry.setAttribute('position', new BufferAttribute(vertices, 3));\n        return geometry;\n      }\n\n      function createTargetMesh() {\n        return new Mesh(scope.sphereGeometry, scope.targetSphereMaterial);\n      }\n\n      function createEffectorMesh() {\n        return new Mesh(scope.sphereGeometry, scope.effectorSphereMaterial);\n      }\n\n      function createLinkMesh() {\n        return new Mesh(scope.sphereGeometry, scope.linkSphereMaterial);\n      }\n\n      function createLine(ik) {\n        return new Line(createLineGeometry(ik), scope.lineMaterial);\n      }\n\n      for (let i = 0, il = iks.length; i < il; i++) {\n        const ik = iks[i];\n        this.add(createTargetMesh());\n        this.add(createEffectorMesh());\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          this.add(createLinkMesh());\n        }\n\n        this.add(createLine(ik));\n      }\n    }\n  });\n  return CCDIKSolver;\n})();\n\nexport { CCDIKSolver };","map":null,"metadata":{},"sourceType":"module"}