{"ast":null,"code":"import { CompressedTextureLoader, CompressedTexture, FileLoader, sRGBEncoding, LinearEncoding } from 'three';\nimport { BasisTextureLoader } from './BasisTextureLoader.js';\nimport { ZSTDDecoder } from 'zstddec';\nimport { read, KTX2Model, KTX2Transfer, KTX2SupercompressionScheme, KTX2ChannelUASTC, KTX2ChannelETC1S, KTX2Flags } from 'ktx-parse';\n/**\n * Loader for KTX 2.0 GPU Texture containers.\n *\n * KTX 2.0 is a container format for various GPU texture formats. The loader\n * supports Basis Universal GPU textures, which can be quickly transcoded to\n * a wide variety of GPU texture compression formats. While KTX 2.0 also allows\n * other hardware-specific formats, this loader does not yet parse them.\n *\n * This loader parses the KTX 2.0 container and then relies on\n * THREE.BasisTextureLoader to complete the transcoding process.\n *\n * References:\n * - KTX: http://github.khronos.org/KTX-Specification/\n * - DFD: https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html#basicdescriptor\n */\n\nclass KTX2Loader extends CompressedTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.basisLoader = new BasisTextureLoader(manager);\n    this.zstd = new ZSTDDecoder();\n    this.zstd.init();\n\n    if (typeof MSC_TRANSCODER !== 'undefined') {\n      console.warn('THREE.KTX2Loader: Please update to latest \"basis_transcoder\".' + ' \"msc_basis_transcoder\" is no longer supported in three.js r125+.');\n    }\n  }\n\n  setTranscoderPath(path) {\n    this.basisLoader.setTranscoderPath(path);\n    return this;\n  }\n\n  setWorkerLimit(path) {\n    this.basisLoader.setWorkerLimit(path);\n    return this;\n  }\n\n  detectSupport(renderer) {\n    this.basisLoader.detectSupport(renderer);\n    return this;\n  }\n\n  dispose() {\n    this.basisLoader.dispose();\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var texture = new CompressedTexture();\n    var bufferPending = new Promise(function (resolve, reject) {\n      new FileLoader(scope.manager).setPath(scope.path).setResponseType('arraybuffer').load(url, resolve, onProgress, reject);\n    });\n    bufferPending.then(function (buffer) {\n      scope.parse(buffer, function (_texture) {\n        texture.copy(_texture);\n        texture.needsUpdate = true;\n        if (onLoad) onLoad(texture);\n      }, onError);\n    }).catch(onError);\n    return texture;\n  }\n\n  parse(buffer, onLoad, onError) {\n    var scope = this;\n    var ktx = read(new Uint8Array(buffer));\n\n    if (ktx.pixelDepth > 0) {\n      throw new Error('THREE.KTX2Loader: Only 2D textures are currently supported.');\n    }\n\n    if (ktx.layerCount > 1) {\n      throw new Error('THREE.KTX2Loader: Array textures are not currently supported.');\n    }\n\n    if (ktx.faceCount > 1) {\n      throw new Error('THREE.KTX2Loader: Cube textures are not currently supported.');\n    }\n\n    var dfd = KTX2Utils.getBasicDFD(ktx);\n    KTX2Utils.createLevels(ktx, this.zstd).then(function (levels) {\n      var basisFormat = dfd.colorModel === KTX2Model.UASTC ? BasisTextureLoader.BasisFormat.UASTC_4x4 : BasisTextureLoader.BasisFormat.ETC1S;\n      var parseConfig = {\n        levels: levels,\n        width: ktx.pixelWidth,\n        height: ktx.pixelHeight,\n        basisFormat: basisFormat,\n        hasAlpha: KTX2Utils.getAlpha(ktx)\n      };\n\n      if (basisFormat === BasisTextureLoader.BasisFormat.ETC1S) {\n        parseConfig.globalData = ktx.globalData;\n      }\n\n      return scope.basisLoader.parseInternalAsync(parseConfig);\n    }).then(function (texture) {\n      texture.encoding = dfd.transferFunction === KTX2Transfer.SRGB ? sRGBEncoding : LinearEncoding;\n      texture.premultiplyAlpha = KTX2Utils.getPremultiplyAlpha(ktx);\n      onLoad(texture);\n    }).catch(onError);\n    return this;\n  }\n\n}\n\nvar KTX2Utils = {\n  createLevels: async function (ktx, zstd) {\n    if (ktx.supercompressionScheme === KTX2SupercompressionScheme.ZSTD) {\n      await zstd.init();\n    }\n\n    var levels = [];\n    var width = ktx.pixelWidth;\n    var height = ktx.pixelHeight;\n\n    for (var levelIndex = 0; levelIndex < ktx.levels.length; levelIndex++) {\n      var levelWidth = Math.max(1, Math.floor(width / Math.pow(2, levelIndex)));\n      var levelHeight = Math.max(1, Math.floor(height / Math.pow(2, levelIndex)));\n      var levelData = ktx.levels[levelIndex].levelData;\n\n      if (ktx.supercompressionScheme === KTX2SupercompressionScheme.ZSTD) {\n        levelData = zstd.decode(levelData, ktx.levels[levelIndex].uncompressedByteLength);\n      }\n\n      levels.push({\n        index: levelIndex,\n        width: levelWidth,\n        height: levelHeight,\n        data: levelData\n      });\n    }\n\n    return levels;\n  },\n  getBasicDFD: function (ktx) {\n    // Basic Data Format Descriptor Block is always the first DFD.\n    return ktx.dataFormatDescriptor[0];\n  },\n  getAlpha: function (ktx) {\n    var dfd = this.getBasicDFD(ktx); // UASTC\n\n    if (dfd.colorModel === KTX2Model.UASTC) {\n      if ((dfd.samples[0].channelID & 0xf) === KTX2ChannelUASTC.RGBA) {\n        return true;\n      }\n\n      return false;\n    } // ETC1S\n\n\n    if (dfd.samples.length === 2 && (dfd.samples[1].channelID & 0xf) === KTX2ChannelETC1S.AAA) {\n      return true;\n    }\n\n    return false;\n  },\n  getPremultiplyAlpha: function (ktx) {\n    var dfd = this.getBasicDFD(ktx);\n    return !!(dfd.flags & KTX2Flags.ALPHA_PREMULTIPLIED);\n  }\n};\nexport { KTX2Loader };","map":null,"metadata":{},"sourceType":"module"}