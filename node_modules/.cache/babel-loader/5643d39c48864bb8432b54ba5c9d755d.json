{"ast":null,"code":"import _slicedToArray from \"/home/zeus/Personal/Portfolio-V2/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useFrame } from '@react-three/fiber';\nimport mergeRefs from 'react-merge-refs';\nimport Composer from 'react-composer';\nimport { Position } from '../helpers/Position.js';\nlet i, instanceRef;\nconst globalContext =\n/*#__PURE__*/\nReact.createContext(null);\nconst parentMatrix = new THREE.Matrix4();\nconst instanceMatrix = new THREE.Matrix4();\nconst tempMatrix = new THREE.Matrix4();\nconst color = new THREE.Color();\nconst translation = new THREE.Vector3();\nconst rotation = new THREE.Quaternion();\nconst scale = new THREE.Vector3();\nconst Instance =\n/*#__PURE__*/\nReact.forwardRef(({\n  context,\n  children,\n  ...props\n}, ref) => {\n  React.useMemo(() => extend({\n    Position\n  }), []);\n  const group = React.useRef();\n\n  const _React$useContext = React.useContext(context || globalContext),\n        subscribe = _React$useContext.subscribe,\n        getParent = _React$useContext.getParent;\n\n  React.useLayoutEffect(() => subscribe(group), []);\n  return (\n    /*#__PURE__*/\n    React.createElement(\"position\", _extends({\n      instance: getParent(),\n      instanceKey: group,\n      ref: mergeRefs([ref, group])\n    }, props), children)\n  );\n});\nconst Instances =\n/*#__PURE__*/\nReact.forwardRef(({\n  children,\n  range,\n  limit = 1000,\n  frames = Infinity,\n  ...props\n}, ref) => {\n  const _React$useState = React.useState(() => {\n    const context =\n    /*#__PURE__*/\n    React.createContext(null);\n    return {\n      context,\n      instance:\n      /*#__PURE__*/\n      React.forwardRef((props, ref) =>\n      /*#__PURE__*/\n      React.createElement(Instance, _extends({\n        context: context\n      }, props, {\n        ref: ref\n      })))\n    };\n  }),\n        _React$useState2 = _slicedToArray(_React$useState, 1),\n        _React$useState2$ = _React$useState2[0],\n        context = _React$useState2$.context,\n        instance = _React$useState2$.instance;\n\n  const parentRef = React.useRef(null);\n\n  const _React$useState3 = React.useState([]),\n        _React$useState4 = _slicedToArray(_React$useState3, 2),\n        instances = _React$useState4[0],\n        setInstances = _React$useState4[1];\n\n  const _React$useState5 = React.useState(() => {\n    const mArray = new Float32Array(limit * 16);\n\n    for (i = 0; i < limit; i++) tempMatrix.identity().toArray(mArray, i * 16);\n\n    return [mArray, new Float32Array([...new Array(limit * 3)].map(() => 1))];\n  }),\n        _React$useState6 = _slicedToArray(_React$useState5, 1),\n        _React$useState6$ = _slicedToArray(_React$useState6[0], 2),\n        matrices = _React$useState6$[0],\n        colors = _React$useState6$[1];\n\n  React.useLayoutEffect(() => {\n    parentRef.current.count = parentRef.current.instanceMatrix.updateRange.count = parentRef.current.instanceColor.updateRange.count = Math.min(limit, range !== undefined ? range : limit, instances.length);\n  }, [instances, range]);\n  React.useEffect(() => {\n    // We might be a frame too late? ðŸ¤·â€â™‚ï¸\n    parentRef.current.instanceMatrix.needsUpdate = true;\n  });\n  let count = 0;\n  useFrame(() => {\n    if (frames === Infinity || count < frames) {\n      parentRef.current.updateMatrix();\n      parentRef.current.updateMatrixWorld();\n      parentMatrix.copy(parentRef.current.matrixWorld).invert();\n\n      for (i = 0; i < instances.length; i++) {\n        instanceRef = instances[i].current; // Multiply the inverse of the InstancedMesh world matrix or else\n        // Instances will be double-transformed if <Instances> isn't at identity\n\n        instanceRef.matrixWorld.decompose(translation, rotation, scale);\n        instanceMatrix.compose(translation, rotation, scale).premultiply(parentMatrix);\n\n        if (!instanceMatrix.equals(tempMatrix.fromArray(matrices, i * 16))) {\n          instanceMatrix.toArray(matrices, i * 16);\n          parentRef.current.instanceMatrix.needsUpdate = true;\n        }\n\n        if (!instanceRef.color.equals(color.fromArray(colors, i * 3))) {\n          instanceRef.color.toArray(colors, i * 3);\n          parentRef.current.instanceColor.needsUpdate = true;\n        }\n      }\n\n      count++;\n    }\n  });\n  const api = React.useMemo(() => ({\n    getParent: () => parentRef,\n    subscribe: ref => {\n      setInstances(instances => [...instances, ref]);\n      return () => setInstances(instances => instances.filter(item => item.current !== ref.current));\n    }\n  }), []);\n  return (\n    /*#__PURE__*/\n    React.createElement(\"instancedMesh\", _extends({\n      userData: {\n        instances\n      },\n      matrixAutoUpdate: false,\n      ref: mergeRefs([ref, parentRef]),\n      args: [null, null, 0],\n      raycast: () => null\n    }, props),\n    /*#__PURE__*/\n    React.createElement(\"instancedBufferAttribute\", {\n      attach: \"instanceMatrix\",\n      count: matrices.length / 16,\n      array: matrices,\n      itemSize: 16,\n      usage: THREE.DynamicDrawUsage\n    }),\n    /*#__PURE__*/\n    React.createElement(\"instancedBufferAttribute\", {\n      attach: \"instanceColor\",\n      count: colors.length / 3,\n      array: colors,\n      itemSize: 3,\n      usage: THREE.DynamicDrawUsage\n    }), typeof children === 'function' ?\n    /*#__PURE__*/\n    React.createElement(context.Provider, {\n      value: api\n    }, children(instance)) :\n    /*#__PURE__*/\n    React.createElement(globalContext.Provider, {\n      value: api\n    }, children))\n  );\n});\n\nfunction Merged({\n  meshes,\n  children,\n  ...props\n}) {\n  const isArray = Array.isArray(meshes); // Filter out meshes from collections, which may contain non-meshes\n\n  if (!isArray) for (const key of Object.keys(meshes)) if (!meshes[key].isMesh) delete meshes[key];\n  return (\n    /*#__PURE__*/\n    React.createElement(Composer, {\n      components: (isArray ? meshes : Object.values(meshes)).map(({\n        geometry,\n        material\n      }) =>\n      /*#__PURE__*/\n      React.createElement(Instances, _extends({\n        key: geometry.uuid,\n        geometry: geometry,\n        material: material\n      }, props)))\n    }, args => isArray ? children(...args) : children(Object.keys(meshes).filter(key => meshes[key].isMesh).reduce((acc, key, i) => ({ ...acc,\n      [key]: args[i]\n    }), {})))\n  );\n}\n\nexport { Instance, Instances, Merged };","map":null,"metadata":{},"sourceType":"module"}